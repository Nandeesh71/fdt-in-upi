{"ast":null,"code":"/**\n * WebAuthn Utility Functions for Biometric Authentication\n * Handles fingerprint/Face ID enrollment and authentication\n */\n\n/* eslint-disable no-undef */\nconst BACKEND_URL = process.env.REACT_APP_BACKEND_URL || 'http://localhost:8001';\n\n// Check if we're on a devtunnel (development domain)\nconst isDevTunnel = () => {\n  return window.location.hostname.includes('devtunnels.ms') || window.location.hostname.includes('localhost') || window.location.hostname === '127.0.0.1';\n};\n\n// WebAuthn doesn't work reliably on devtunnel domains on mobile\n// It will work fine in production on real domains\nconst WEBAUTHN_AVAILABLE = !isDevTunnel();\n\n/**\n * Check if WebAuthn is supported in the current browser\n */\nexport const isWebAuthnSupported = () => {\n  if (!WEBAUTHN_AVAILABLE) {\n    console.warn('‚ÑπÔ∏è WebAuthn not available on development domain. Works in production.');\n    return false;\n  }\n  return typeof window !== 'undefined' && window.PublicKeyCredential !== undefined && navigator.credentials !== undefined;\n};\n\n/**\n * Check if platform authenticator (fingerprint/Face ID) is available\n */\nexport const isPlatformAuthenticatorAvailable = async () => {\n  if (!isWebAuthnSupported()) return false;\n  try {\n    const available = await window.PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable();\n    return available;\n  } catch (error) {\n    console.error('Error checking platform authenticator:', error);\n    return false;\n  }\n};\n\n/**\n * Convert base64url string to ArrayBuffer\n */\nconst base64urlToBuffer = base64url => {\n  const base64 = base64url.replace(/-/g, '+').replace(/_/g, '/');\n  const padLen = (4 - base64.length % 4) % 4;\n  const padded = base64 + '='.repeat(padLen);\n  const binary = atob(padded);\n  const bytes = new Uint8Array(binary.length);\n  for (let i = 0; i < binary.length; i++) {\n    bytes[i] = binary.charCodeAt(i);\n  }\n  return bytes.buffer;\n};\n\n/**\n * Convert ArrayBuffer to base64url string\n */\nconst bufferToBase64url = buffer => {\n  const bytes = new Uint8Array(buffer);\n  let binary = '';\n  for (let i = 0; i < bytes.byteLength; i++) {\n    binary += String.fromCharCode(bytes[i]);\n  }\n  return btoa(binary).replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '');\n};\n\n/**\n * Register a new biometric credential\n * @param {string} deviceName - Optional name for the device\n * @returns {Promise<Object>} Registration result\n */\nexport const registerBiometric = async (deviceName = null) => {\n  try {\n    // Check if WebAuthn is supported\n    if (!isWebAuthnSupported()) {\n      throw new Error('WebAuthn is not supported in this browser');\n    }\n\n    // Check for platform authenticator\n    const available = await isPlatformAuthenticatorAvailable();\n    if (!available) {\n      throw new Error('No biometric authenticator available on this device');\n    }\n\n    // Get authentication token\n    const token = localStorage.getItem('fdt_token');\n    if (!token) {\n      throw new Error('User not authenticated');\n    }\n\n    // Request challenge from server\n    const challengeResponse = await fetch(`${BACKEND_URL}/api/auth/register-challenge`, {\n      method: 'POST',\n      headers: {\n        'Authorization': `Bearer ${token}`,\n        'Content-Type': 'application/json'\n      }\n    });\n    if (!challengeResponse.ok) {\n      throw new Error('Failed to get registration challenge');\n    }\n    const {\n      challenge,\n      user_id\n    } = await challengeResponse.json();\n    console.log('üîê WebAuthn Registration Starting:', {\n      hostname: window.location.hostname,\n      challenge: challenge.substring(0, 20) + '...'\n    });\n\n    // Create credential\n    const publicKeyCredentialCreationOptions = {\n      challenge: base64urlToBuffer(challenge),\n      rp: {\n        name: 'FDT - Fraud Detection',\n        id: window.location.hostname\n      },\n      user: {\n        id: new TextEncoder().encode(user_id),\n        name: user_id,\n        displayName: user_id\n      },\n      pubKeyCredParams: [{\n        alg: -7,\n        type: 'public-key'\n      },\n      // ES256\n      {\n        alg: -257,\n        type: 'public-key'\n      } // RS256\n      ],\n      authenticatorSelection: {\n        authenticatorAttachment: 'platform',\n        requireResidentKey: false,\n        userVerification: 'required'\n      },\n      timeout: 60000,\n      attestation: 'none'\n    };\n    console.log('üì± Calling navigator.credentials.create()...');\n    let credential;\n    try {\n      // Create a timeout promise\n      const timeoutPromise = new Promise((_, reject) => setTimeout(() => {\n        console.error('‚è±Ô∏è WebAuthn timeout after 5 seconds');\n        reject(new Error('WebAuthn request timed out - your device may not support this operation'));\n      }, 5000));\n\n      // Race between credential creation and timeout\n      credential = await Promise.race([navigator.credentials.create({\n        publicKey: publicKeyCredentialCreationOptions\n      }), timeoutPromise]);\n    } catch (e) {\n      console.error('‚ùå navigator.credentials.create() failed:', e);\n      throw e;\n    }\n    console.log('‚úÖ Credential created successfully');\n    if (!credential) {\n      throw new Error('Credential creation failed');\n    }\n    console.log('üîê Extracting credential data...');\n    try {\n      // Extract credential data\n      const credentialId = bufferToBase64url(credential.rawId);\n      console.log('‚úÖ Credential ID:', credentialId.substring(0, 20) + '...');\n      let publicKey;\n      try {\n        publicKey = bufferToBase64url(credential.response.getPublicKey());\n        console.log('‚úÖ Public key extracted:', publicKey.substring(0, 20) + '...');\n      } catch (pkError) {\n        console.warn('‚ö†Ô∏è getPublicKey() not available, using attestationObject');\n        // Fallback: encode the entire attestation object\n        const attestationObject = credential.response.attestationObject;\n        publicKey = bufferToBase64url(new Uint8Array(attestationObject));\n      }\n      const aaguid = credential.response.getAuthenticatorData ? bufferToBase64url(credential.response.getAuthenticatorData().slice(37, 53)) : null;\n      console.log('‚úÖ AAGUID:', aaguid);\n\n      // Get transports if available\n      const transports = credential.response.getTransports ? credential.response.getTransports() : [];\n      console.log('‚úÖ Transports:', transports);\n\n      // Register credential with server\n      console.log('üì§ Sending credential to server...');\n      const registerResponse = await fetch(`${BACKEND_URL}/api/auth/register-credential`, {\n        method: 'POST',\n        headers: {\n          'Authorization': `Bearer ${token}`,\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          credential_id: credentialId,\n          public_key: publicKey,\n          device_name: deviceName,\n          aaguid: aaguid,\n          transports: transports\n        })\n      });\n      console.log('üì° Server response status:', registerResponse.status);\n      if (!registerResponse.ok) {\n        const error = await registerResponse.json();\n        console.error('‚ùå Server error:', error);\n        throw new Error(error.detail || 'Failed to register credential');\n      }\n      const result = await registerResponse.json();\n      console.log('‚úÖ Credential registered successfully:', result);\n    } catch (extractError) {\n      console.error('‚ùå Error extracting credential:', extractError);\n      throw extractError;\n    }\n    storedCredentials.push({\n      id: credentialId,\n      name: deviceName || result.credential.credential_name,\n      created: new Date().toISOString()\n    });\n    localStorage.setItem('fdt_credentials', JSON.stringify(storedCredentials));\n    return result;\n  } catch (error) {\n    console.error('‚ùå Biometric registration error:', error);\n    console.error('Error details:', {\n      name: error.name,\n      message: error.message,\n      code: error.code\n    });\n    throw error;\n  }\n};\n\n/**\n * Authenticate using biometric credential\n * @param {string} phone - User's phone number\n * @returns {Promise<Object>} Authentication result with token\n */\nexport const authenticateWithBiometric = async phone => {\n  try {\n    // Check if WebAuthn is supported\n    if (!isWebAuthnSupported()) {\n      throw new Error('WebAuthn is not supported in this browser');\n    }\n\n    // Request challenge from server\n    const challengeResponse = await fetch(`${BACKEND_URL}/api/auth/login-challenge`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({\n        phone\n      })\n    });\n    if (!challengeResponse.ok) {\n      const error = await challengeResponse.json();\n      throw new Error(error.detail || 'Failed to get login challenge');\n    }\n    const {\n      challenge,\n      allowCredentials\n    } = await challengeResponse.json();\n\n    // Prepare credential request\n    const publicKeyCredentialRequestOptions = {\n      challenge: base64urlToBuffer(challenge),\n      allowCredentials: allowCredentials.map(cred => ({\n        id: base64urlToBuffer(cred.id),\n        type: 'public-key',\n        transports: ['internal', 'hybrid']\n      })),\n      userVerification: 'required',\n      timeout: 60000\n    };\n\n    // Get credential\n    const assertion = await navigator.credentials.get({\n      publicKey: publicKeyCredentialRequestOptions\n    });\n    if (!assertion) {\n      throw new Error('Authentication failed');\n    }\n\n    // Extract assertion data\n    const credentialId = bufferToBase64url(assertion.rawId);\n    const authenticatorData = bufferToBase64url(assertion.response.authenticatorData);\n    const clientDataJSON = bufferToBase64url(assertion.response.clientDataJSON);\n    const signature = bufferToBase64url(assertion.response.signature);\n    const userHandle = assertion.response.userHandle ? bufferToBase64url(assertion.response.userHandle) : null;\n\n    // Send to server for verification\n    const authResponse = await fetch(`${BACKEND_URL}/api/auth/authenticate-credential`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({\n        credential_id: credentialId,\n        authenticator_data: authenticatorData,\n        client_data_json: clientDataJSON,\n        signature: signature,\n        user_handle: userHandle\n      })\n    });\n    if (!authResponse.ok) {\n      const error = await authResponse.json();\n      throw new Error(error.detail || 'Authentication failed');\n    }\n    const result = await authResponse.json();\n\n    // Store token and user data\n    localStorage.setItem('fdt_token', result.token);\n    localStorage.setItem('fdt_user', JSON.stringify(result.user));\n    return result;\n  } catch (error) {\n    console.error('Biometric authentication error:', error);\n    throw error;\n  }\n};\n\n/**\n * Check if user has stored credentials\n * @returns {boolean}\n */\nexport const hasStoredCredentials = () => {\n  const credentials = localStorage.getItem('fdt_credentials');\n  return credentials && JSON.parse(credentials).length > 0;\n};\n\n/**\n * Get list of registered credentials from server\n * @returns {Promise<Array>}\n */\nexport const getRegisteredCredentials = async () => {\n  try {\n    const token = localStorage.getItem('fdt_token');\n    if (!token) {\n      throw new Error('User not authenticated');\n    }\n    console.log('üîë Fetching registered credentials...');\n    const response = await fetch(`${BACKEND_URL}/api/auth/credentials`, {\n      method: 'GET',\n      headers: {\n        'Authorization': `Bearer ${token}`,\n        'Content-Type': 'application/json'\n      }\n    });\n    console.log('üì° Response status:', response.status);\n    if (!response.ok) {\n      throw new Error('Failed to fetch credentials');\n    }\n    const data = await response.json();\n    console.log('üìã Credentials data:', data);\n    const credentials = data.credentials || [];\n    console.log('‚úÖ Loaded', credentials.length, 'credentials');\n    return credentials;\n  } catch (error) {\n    console.error('‚ùå Error fetching credentials:', error);\n    throw error;\n  }\n};\n\n/**\n * Revoke a credential\n * @param {string} credentialId\n * @returns {Promise<Object>}\n */\nexport const revokeCredential = async credentialId => {\n  try {\n    const token = localStorage.getItem('fdt_token');\n    if (!token) {\n      throw new Error('User not authenticated');\n    }\n    const response = await fetch(`${BACKEND_URL}/api/auth/credentials/${credentialId}`, {\n      method: 'DELETE',\n      headers: {\n        'Authorization': `Bearer ${token}`,\n        'Content-Type': 'application/json'\n      }\n    });\n    if (!response.ok) {\n      const error = await response.json();\n      throw new Error(error.detail || 'Failed to revoke credential');\n    }\n    const result = await response.json();\n\n    // Remove from local storage\n    const storedCredentials = JSON.parse(localStorage.getItem('fdt_credentials') || '[]');\n    const updated = storedCredentials.filter(c => c.id !== credentialId);\n    localStorage.setItem('fdt_credentials', JSON.stringify(updated));\n    return result;\n  } catch (error) {\n    console.error('Error revoking credential:', error);\n    throw error;\n  }\n};","map":{"version":3,"names":["BACKEND_URL","process","env","REACT_APP_BACKEND_URL","isDevTunnel","window","location","hostname","includes","WEBAUTHN_AVAILABLE","isWebAuthnSupported","console","warn","PublicKeyCredential","undefined","navigator","credentials","isPlatformAuthenticatorAvailable","available","isUserVerifyingPlatformAuthenticatorAvailable","error","base64urlToBuffer","base64url","base64","replace","padLen","length","padded","repeat","binary","atob","bytes","Uint8Array","i","charCodeAt","buffer","bufferToBase64url","byteLength","String","fromCharCode","btoa","registerBiometric","deviceName","Error","token","localStorage","getItem","challengeResponse","fetch","method","headers","ok","challenge","user_id","json","log","substring","publicKeyCredentialCreationOptions","rp","name","id","user","TextEncoder","encode","displayName","pubKeyCredParams","alg","type","authenticatorSelection","authenticatorAttachment","requireResidentKey","userVerification","timeout","attestation","credential","timeoutPromise","Promise","_","reject","setTimeout","race","create","publicKey","e","credentialId","rawId","response","getPublicKey","pkError","attestationObject","aaguid","getAuthenticatorData","slice","transports","getTransports","registerResponse","body","JSON","stringify","credential_id","public_key","device_name","status","detail","result","extractError","storedCredentials","push","credential_name","created","Date","toISOString","setItem","message","code","authenticateWithBiometric","phone","allowCredentials","publicKeyCredentialRequestOptions","map","cred","assertion","get","authenticatorData","clientDataJSON","signature","userHandle","authResponse","authenticator_data","client_data_json","user_handle","hasStoredCredentials","parse","getRegisteredCredentials","data","revokeCredential","updated","filter","c"],"sources":["/home/aakash/Projects/Fraud-Detection-in-UPI---FDT2/frontend/src/utils/webauthn.js"],"sourcesContent":["/**\n * WebAuthn Utility Functions for Biometric Authentication\n * Handles fingerprint/Face ID enrollment and authentication\n */\n\n/* eslint-disable no-undef */\nconst BACKEND_URL = process.env.REACT_APP_BACKEND_URL || 'http://localhost:8001';\n\n// Check if we're on a devtunnel (development domain)\nconst isDevTunnel = () => {\n  return window.location.hostname.includes('devtunnels.ms') || \n         window.location.hostname.includes('localhost') ||\n         window.location.hostname === '127.0.0.1';\n};\n\n// WebAuthn doesn't work reliably on devtunnel domains on mobile\n// It will work fine in production on real domains\nconst WEBAUTHN_AVAILABLE = !isDevTunnel();\n\n/**\n * Check if WebAuthn is supported in the current browser\n */\nexport const isWebAuthnSupported = () => {\n  if (!WEBAUTHN_AVAILABLE) {\n    console.warn('‚ÑπÔ∏è WebAuthn not available on development domain. Works in production.');\n    return false;\n  }\n  return typeof window !== 'undefined' && \n         window.PublicKeyCredential !== undefined && \n         navigator.credentials !== undefined;\n};\n\n/**\n * Check if platform authenticator (fingerprint/Face ID) is available\n */\nexport const isPlatformAuthenticatorAvailable = async () => {\n  if (!isWebAuthnSupported()) return false;\n  \n  try {\n    const available = await window.PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable();\n    return available;\n  } catch (error) {\n    console.error('Error checking platform authenticator:', error);\n    return false;\n  }\n};\n\n/**\n * Convert base64url string to ArrayBuffer\n */\nconst base64urlToBuffer = (base64url) => {\n  const base64 = base64url.replace(/-/g, '+').replace(/_/g, '/');\n  const padLen = (4 - (base64.length % 4)) % 4;\n  const padded = base64 + '='.repeat(padLen);\n  const binary = atob(padded);\n  const bytes = new Uint8Array(binary.length);\n  for (let i = 0; i < binary.length; i++) {\n    bytes[i] = binary.charCodeAt(i);\n  }\n  return bytes.buffer;\n};\n\n/**\n * Convert ArrayBuffer to base64url string\n */\nconst bufferToBase64url = (buffer) => {\n  const bytes = new Uint8Array(buffer);\n  let binary = '';\n  for (let i = 0; i < bytes.byteLength; i++) {\n    binary += String.fromCharCode(bytes[i]);\n  }\n  return btoa(binary)\n    .replace(/\\+/g, '-')\n    .replace(/\\//g, '_')\n    .replace(/=/g, '');\n};\n\n/**\n * Register a new biometric credential\n * @param {string} deviceName - Optional name for the device\n * @returns {Promise<Object>} Registration result\n */\nexport const registerBiometric = async (deviceName = null) => {\n  try {\n    // Check if WebAuthn is supported\n    if (!isWebAuthnSupported()) {\n      throw new Error('WebAuthn is not supported in this browser');\n    }\n\n    // Check for platform authenticator\n    const available = await isPlatformAuthenticatorAvailable();\n    if (!available) {\n      throw new Error('No biometric authenticator available on this device');\n    }\n\n    // Get authentication token\n    const token = localStorage.getItem('fdt_token');\n    if (!token) {\n      throw new Error('User not authenticated');\n    }\n\n    // Request challenge from server\n    const challengeResponse = await fetch(`${BACKEND_URL}/api/auth/register-challenge`, {\n      method: 'POST',\n      headers: {\n        'Authorization': `Bearer ${token}`,\n        'Content-Type': 'application/json'\n      }\n    });\n\n    if (!challengeResponse.ok) {\n      throw new Error('Failed to get registration challenge');\n    }\n\n    const { challenge, user_id } = await challengeResponse.json();\n    \n    console.log('üîê WebAuthn Registration Starting:', {\n      hostname: window.location.hostname,\n      challenge: challenge.substring(0, 20) + '...'\n    });\n\n    // Create credential\n    const publicKeyCredentialCreationOptions = {\n      challenge: base64urlToBuffer(challenge),\n      rp: {\n        name: 'FDT - Fraud Detection',\n        id: window.location.hostname\n      },\n      user: {\n        id: new TextEncoder().encode(user_id),\n        name: user_id,\n        displayName: user_id\n      },\n      pubKeyCredParams: [\n        { alg: -7, type: 'public-key' },  // ES256\n        { alg: -257, type: 'public-key' } // RS256\n      ],\n      authenticatorSelection: {\n        authenticatorAttachment: 'platform',\n        requireResidentKey: false,\n        userVerification: 'required'\n      },\n      timeout: 60000,\n      attestation: 'none'\n    };\n\n    console.log('üì± Calling navigator.credentials.create()...');\n    \n    let credential;\n    try {\n      // Create a timeout promise\n      const timeoutPromise = new Promise((_, reject) => \n        setTimeout(() => {\n          console.error('‚è±Ô∏è WebAuthn timeout after 5 seconds');\n          reject(new Error('WebAuthn request timed out - your device may not support this operation'));\n        }, 5000)\n      );\n      \n      // Race between credential creation and timeout\n      credential = await Promise.race([\n        navigator.credentials.create({\n          publicKey: publicKeyCredentialCreationOptions\n        }),\n        timeoutPromise\n      ]);\n    } catch (e) {\n      console.error('‚ùå navigator.credentials.create() failed:', e);\n      throw e;\n    }\n    \n    console.log('‚úÖ Credential created successfully');\n\n    if (!credential) {\n      throw new Error('Credential creation failed');\n    }\n\n    console.log('üîê Extracting credential data...');\n    \n    try {\n      // Extract credential data\n      const credentialId = bufferToBase64url(credential.rawId);\n      console.log('‚úÖ Credential ID:', credentialId.substring(0, 20) + '...');\n      \n      let publicKey;\n      try {\n        publicKey = bufferToBase64url(credential.response.getPublicKey());\n        console.log('‚úÖ Public key extracted:', publicKey.substring(0, 20) + '...');\n      } catch (pkError) {\n        console.warn('‚ö†Ô∏è getPublicKey() not available, using attestationObject');\n        // Fallback: encode the entire attestation object\n        const attestationObject = credential.response.attestationObject;\n        publicKey = bufferToBase64url(new Uint8Array(attestationObject));\n      }\n      \n      const aaguid = credential.response.getAuthenticatorData ? \n        bufferToBase64url(credential.response.getAuthenticatorData().slice(37, 53)) : null;\n      console.log('‚úÖ AAGUID:', aaguid);\n\n      // Get transports if available\n      const transports = credential.response.getTransports ? \n        credential.response.getTransports() : [];\n      console.log('‚úÖ Transports:', transports);\n\n      // Register credential with server\n      console.log('üì§ Sending credential to server...');\n      const registerResponse = await fetch(`${BACKEND_URL}/api/auth/register-credential`, {\n        method: 'POST',\n        headers: {\n          'Authorization': `Bearer ${token}`,\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          credential_id: credentialId,\n          public_key: publicKey,\n          device_name: deviceName,\n          aaguid: aaguid,\n          transports: transports\n        })\n      });\n\n      console.log('üì° Server response status:', registerResponse.status);\n\n      if (!registerResponse.ok) {\n        const error = await registerResponse.json();\n        console.error('‚ùå Server error:', error);\n        throw new Error(error.detail || 'Failed to register credential');\n      }\n      \n      const result = await registerResponse.json();\n      console.log('‚úÖ Credential registered successfully:', result);\n    } catch (extractError) {\n      console.error('‚ùå Error extracting credential:', extractError);\n      throw extractError;\n    }\n    storedCredentials.push({\n      id: credentialId,\n      name: deviceName || result.credential.credential_name,\n      created: new Date().toISOString()\n    });\n    localStorage.setItem('fdt_credentials', JSON.stringify(storedCredentials));\n\n    return result;\n  } catch (error) {\n    console.error('‚ùå Biometric registration error:', error);\n    console.error('Error details:', {\n      name: error.name,\n      message: error.message,\n      code: error.code\n    });\n    throw error;\n  }\n};\n\n/**\n * Authenticate using biometric credential\n * @param {string} phone - User's phone number\n * @returns {Promise<Object>} Authentication result with token\n */\nexport const authenticateWithBiometric = async (phone) => {\n  try {\n    // Check if WebAuthn is supported\n    if (!isWebAuthnSupported()) {\n      throw new Error('WebAuthn is not supported in this browser');\n    }\n\n    // Request challenge from server\n    const challengeResponse = await fetch(`${BACKEND_URL}/api/auth/login-challenge`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({ phone })\n    });\n\n    if (!challengeResponse.ok) {\n      const error = await challengeResponse.json();\n      throw new Error(error.detail || 'Failed to get login challenge');\n    }\n\n    const { challenge, allowCredentials } = await challengeResponse.json();\n\n    // Prepare credential request\n    const publicKeyCredentialRequestOptions = {\n      challenge: base64urlToBuffer(challenge),\n      allowCredentials: allowCredentials.map(cred => ({\n        id: base64urlToBuffer(cred.id),\n        type: 'public-key',\n        transports: ['internal', 'hybrid']\n      })),\n      userVerification: 'required',\n      timeout: 60000\n    };\n\n    // Get credential\n    const assertion = await navigator.credentials.get({\n      publicKey: publicKeyCredentialRequestOptions\n    });\n\n    if (!assertion) {\n      throw new Error('Authentication failed');\n    }\n\n    // Extract assertion data\n    const credentialId = bufferToBase64url(assertion.rawId);\n    const authenticatorData = bufferToBase64url(assertion.response.authenticatorData);\n    const clientDataJSON = bufferToBase64url(assertion.response.clientDataJSON);\n    const signature = bufferToBase64url(assertion.response.signature);\n    const userHandle = assertion.response.userHandle ? \n      bufferToBase64url(assertion.response.userHandle) : null;\n\n    // Send to server for verification\n    const authResponse = await fetch(`${BACKEND_URL}/api/auth/authenticate-credential`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({\n        credential_id: credentialId,\n        authenticator_data: authenticatorData,\n        client_data_json: clientDataJSON,\n        signature: signature,\n        user_handle: userHandle\n      })\n    });\n\n    if (!authResponse.ok) {\n      const error = await authResponse.json();\n      throw new Error(error.detail || 'Authentication failed');\n    }\n\n    const result = await authResponse.json();\n\n    // Store token and user data\n    localStorage.setItem('fdt_token', result.token);\n    localStorage.setItem('fdt_user', JSON.stringify(result.user));\n\n    return result;\n  } catch (error) {\n    console.error('Biometric authentication error:', error);\n    throw error;\n  }\n};\n\n/**\n * Check if user has stored credentials\n * @returns {boolean}\n */\nexport const hasStoredCredentials = () => {\n  const credentials = localStorage.getItem('fdt_credentials');\n  return credentials && JSON.parse(credentials).length > 0;\n};\n\n/**\n * Get list of registered credentials from server\n * @returns {Promise<Array>}\n */\nexport const getRegisteredCredentials = async () => {\n  try {\n    const token = localStorage.getItem('fdt_token');\n    if (!token) {\n      throw new Error('User not authenticated');\n    }\n\n    console.log('üîë Fetching registered credentials...');\n    const response = await fetch(`${BACKEND_URL}/api/auth/credentials`, {\n      method: 'GET',\n      headers: {\n        'Authorization': `Bearer ${token}`,\n        'Content-Type': 'application/json'\n      }\n    });\n\n    console.log('üì° Response status:', response.status);\n\n    if (!response.ok) {\n      throw new Error('Failed to fetch credentials');\n    }\n\n    const data = await response.json();\n    console.log('üìã Credentials data:', data);\n    \n    const credentials = data.credentials || [];\n    console.log('‚úÖ Loaded', credentials.length, 'credentials');\n    \n    return credentials;\n  } catch (error) {\n    console.error('‚ùå Error fetching credentials:', error);\n    throw error;\n  }\n};\n\n/**\n * Revoke a credential\n * @param {string} credentialId\n * @returns {Promise<Object>}\n */\nexport const revokeCredential = async (credentialId) => {\n  try {\n    const token = localStorage.getItem('fdt_token');\n    if (!token) {\n      throw new Error('User not authenticated');\n    }\n\n    const response = await fetch(`${BACKEND_URL}/api/auth/credentials/${credentialId}`, {\n      method: 'DELETE',\n      headers: {\n        'Authorization': `Bearer ${token}`,\n        'Content-Type': 'application/json'\n      }\n    });\n\n    if (!response.ok) {\n      const error = await response.json();\n      throw new Error(error.detail || 'Failed to revoke credential');\n    }\n\n    const result = await response.json();\n\n    // Remove from local storage\n    const storedCredentials = JSON.parse(localStorage.getItem('fdt_credentials') || '[]');\n    const updated = storedCredentials.filter(c => c.id !== credentialId);\n    localStorage.setItem('fdt_credentials', JSON.stringify(updated));\n\n    return result;\n  } catch (error) {\n    console.error('Error revoking credential:', error);\n    throw error;\n  }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}