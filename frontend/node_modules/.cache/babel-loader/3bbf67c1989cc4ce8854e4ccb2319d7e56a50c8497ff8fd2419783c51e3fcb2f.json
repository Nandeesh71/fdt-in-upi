{"ast":null,"code":"import _objectSpread from\"C:/Users/jerol/OneDrive/Desktop/FDT_HOST/fdt-in-upi/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";import React,{useState,useEffect,createContext,useContext,useCallback}from'react';import{getUserTransactions,getAuthToken}from'../api';// FIX: import getAuthToken from api.js so the 401 check reads from the same\n//      sessionStorage key that login writes to, instead of localStorage.\nimport{jsx as _jsx}from\"react/jsx-runtime\";const NotificationContext=/*#__PURE__*/createContext();export const useNotifications=()=>{const context=useContext(NotificationContext);if(!context){throw new Error('useNotifications must be used within a NotificationProvider');}return context;};export const NotificationProvider=_ref=>{let{children}=_ref;const[notifications,setNotifications]=useState([]);const[showNotificationPanel,setShowNotificationPanel]=useState(false);const addNotification=useCallback(notification=>{const id=Date.now()+Math.random();const newNotification=_objectSpread({id,timestamp:new Date(),read:false},notification);setNotifications(prev=>[newNotification,...prev]);// Auto-remove non-persistent notifications after 10 s\nif(notification.type!=='delayed_transaction'){setTimeout(()=>{setNotifications(prev=>prev.filter(n=>n.id!==id));},10000);}},[]);const removeNotification=useCallback(id=>{setNotifications(prev=>prev.filter(n=>n.id!==id));},[]);const markAsRead=useCallback(id=>{setNotifications(prev=>prev.map(n=>n.id===id?_objectSpread(_objectSpread({},n),{},{read:true}):n));},[]);const clearAll=useCallback(()=>setNotifications([]),[]);// Poll for delayed transactions (only while authenticated)\nuseEffect(()=>{// FIX: was reading from localStorage.getItem('fdt_token') while the token\n//      lives in sessionStorage – so this guard always bailed out early and\n//      the interval was never started, yet when it DID fire (e.g. after a\n//      page reload where sessionStorage was still populated) the request\n//      lacked a token and returned 401.  Using getAuthToken() ensures we\n//      read from the correct store.\nconst token=getAuthToken();if(!token)return;const checkDelayedTransactions=async()=>{try{const data=await getUserTransactions(20,'DELAY');const delayedTxns=data.transactions||[];delayedTxns.forEach(tx=>{const existingNotification=notifications.find(n=>n.type==='delayed_transaction'&&n.transactionId===tx.tx_id&&n.read===false);if(!existingNotification){addNotification({type:'delayed_transaction',title:'Transaction Pending Verification',message:\"Transaction of \\u20B9\".concat(tx.amount,\" to \").concat(tx.recipient_vpa,\" needs your confirmation\"),transactionId:tx.tx_id,action:'review',actionText:'Review Now',actionUrl:\"/fraud-alert/\".concat(tx.tx_id)});}});}catch(err){console.error('Failed to check delayed transactions:',err);// 401s are already handled globally by the axios interceptor in api.js\n// (it clears the token and redirects to /login), so no extra handling needed here.\n}};// Check immediately, then every 30 s\ncheckDelayedTransactions();const interval=setInterval(checkDelayedTransactions,30000);return()=>clearInterval(interval);// eslint-disable-next-line react-hooks/exhaustive-deps\n},[addNotification]);// FIX: removed `notifications` from the dependency array – it was causing\n//      a new interval to be registered on every state change (i.e. every\n//      time a notification was added/removed), leading to rapid-fire requests\n//      that all came back 401 because the interceptor had already wiped the\n//      token on the first failure.\nconst unreadCount=notifications.filter(n=>!n.read).length;return/*#__PURE__*/_jsx(NotificationContext.Provider,{value:{notifications,addNotification,removeNotification,markAsRead,clearAll,showNotificationPanel,setShowNotificationPanel,unreadCount},children:children});};export default NotificationContext;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}