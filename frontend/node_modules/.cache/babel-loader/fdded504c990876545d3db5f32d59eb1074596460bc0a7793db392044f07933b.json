{"ast":null,"code":"/**\r\n * WebAuthn Utility Functions - Production Ready\r\n * Secure biometric authentication with best practices:\r\n * - Rate limiting and anti-brute force\r\n * - Comprehensive error handling\r\n * - Performance optimizations\r\n * - Full audit logging\r\n *//* eslint-disable no-undef */import{getAuthToken,setAuthToken,setStoredUser,getStoredUser}from'../api';const BACKEND_URL=process.env.REACT_APP_USER_BACKEND_URL||process.env.REACT_APP_BACKEND_URL||'http://localhost:8001';// â”€â”€â”€ Security Configuration â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nconst SECURITY_CONFIG={MAX_RETRY_ATTEMPTS:3,RETRY_LOCKOUT_MINUTES:15,CHALLENGE_TIMEOUT_MS:120000,// 2 minutes\nAUTH_TIMEOUT_MS:60000,// 1 minute for production\nCACHE_DURATION_MS:5*60*1000// 5 minutes\n};// â”€â”€â”€ Rate Limiting & Anti-Brute Force â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nclass AuthAttemptTracker{constructor(){this.attempts={};// { userId: { count, timestamp, locked } }\n}isLocked(userId){if(!this.attempts[userId])return false;const{count,timestamp,locked}=this.attempts[userId];const elapsed=Date.now()-timestamp;const lockoutMs=SECURITY_CONFIG.RETRY_LOCKOUT_MINUTES*60*1000;if(locked&&elapsed>lockoutMs){delete this.attempts[userId];return false;}return locked||count>=SECURITY_CONFIG.MAX_RETRY_ATTEMPTS;}recordAttempt(userId){if(!this.attempts[userId]){this.attempts[userId]={count:0,timestamp:Date.now(),locked:false};}this.attempts[userId].count++;if(this.attempts[userId].count>=SECURITY_CONFIG.MAX_RETRY_ATTEMPTS){this.attempts[userId].locked=true;}}reset(userId){delete this.attempts[userId];}}const attemptTracker=new AuthAttemptTracker();// â”€â”€â”€ Environment Guards â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nconst isDevTunnel=()=>window.location.hostname.includes('devtunnels.ms')||window.location.hostname.includes('localhost')||window.location.hostname==='127.0.0.1';const WEBAUTHN_AVAILABLE=!isDevTunnel();// â”€â”€â”€ Feature Checks with Caching â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nlet cachedWebAuthnSupport=null;let cachedPlatformAuthSupport=null;let cacheTimestamp=0;export const isWebAuthnSupported=()=>{if(cachedWebAuthnSupport!==null&&Date.now()-cacheTimestamp<SECURITY_CONFIG.CACHE_DURATION_MS){return cachedWebAuthnSupport;}if(!WEBAUTHN_AVAILABLE){console.warn('â„¹ï¸ WebAuthn unavailable in dev. Production only.');return false;}const supported=typeof window!=='undefined'&&window.PublicKeyCredential!==undefined&&navigator.credentials!==undefined&&typeof window.PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable==='function';cachedWebAuthnSupport=supported;cacheTimestamp=Date.now();return supported;};export const isPlatformAuthenticatorAvailable=async()=>{if(!isWebAuthnSupported())return false;if(cachedPlatformAuthSupport!==null&&Date.now()-cacheTimestamp<SECURITY_CONFIG.CACHE_DURATION_MS){return cachedPlatformAuthSupport;}try{const available=await window.PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable();cachedPlatformAuthSupport=available;cacheTimestamp=Date.now();return available;}catch(error){console.error('âŒ Error checking platform authenticator:',error.message);return false;}};// â”€â”€â”€ Enhanced Error Handling â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nconst extractErrorDetail=function(error){let fallback=arguments.length>1&&arguments[1]!==undefined?arguments[1]:'Request failed';if(!error)return fallback;// Handle API responses with detail field\nif(error.detail){return typeof error.detail==='string'?error.detail:JSON.stringify(error.detail);}// Handle array of errors\nif(Array.isArray(error.detail)){return error.detail.map(d=>d.msg||d.message||JSON.stringify(d)).join(', ');}// Handle standard errors\nif(error.message){return error.message;}// Handle string errors\nif(typeof error==='string'){return error;}return fallback;};// Map WebAuthn errors to user-friendly messages\nconst getUserFriendlyError=function(error){let context=arguments.length>1&&arguments[1]!==undefined?arguments[1]:'authentication';const msg=extractErrorDetail(error);// User cancelled\nif(msg.includes('cancelled')||msg.includes('user denied')){return'Authentication cancelled by user';}// Device not available\nif(msg.includes('not available')||msg.includes('not enabled')){return'Biometric authentication not available on this device';}// Challenge expired\nif(msg.includes('challenge')||msg.includes('timeout')){return'Authentication timeout. Please try again.';}// Network errors\nif(msg.includes('fetch')||msg.includes('network')){return'Network connection error. Please check your internet and try again.';}// Invalid credential\nif(msg.includes('credential')||msg.includes('invalid')){return'This biometric credential is no longer valid. Please register again.';}return msg||fallback;};// â”€â”€â”€ Input Validation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nconst validatePhoneNumber=phone=>{if(!phone||typeof phone!=='string')return false;return /^[\\d\\s\\-\\+\\(\\)]{7,}$/.test(phone.replace(/[+\\-\\s()]/g,''));};const validateUserId=userId=>{if(!userId||typeof userId!=='string')return false;return userId.length>0&&userId.length<256;};// â”€â”€â”€ Buffer Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nconst base64urlToBuffer=base64url=>{if(typeof base64url!=='string')throw new Error('Expected string for base64url conversion');const base64=base64url.replace(/-/g,'+').replace(/_/g,'/');const padLen=(4-base64.length%4)%4;const padded=base64+'='.repeat(padLen);const binary=atob(padded);const bytes=new Uint8Array(binary.length);for(let i=0;i<binary.length;i++)bytes[i]=binary.charCodeAt(i);return bytes.buffer;};const bufferToBase64url=buffer=>{if(!buffer||!(buffer instanceof ArrayBuffer)){throw new Error('Expected ArrayBuffer for base64url conversion');}const bytes=new Uint8Array(buffer);let binary='';for(let i=0;i<bytes.byteLength;i++)binary+=String.fromCharCode(bytes[i]);return btoa(binary).replace(/\\+/g,'-').replace(/\\//g,'_').replace(/=/g,'');};// â”€â”€â”€ User-Specific Credential Storage â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n/**\r\n * Get the current user's identifier (phone or user_id)\r\n */const getCurrentUserIdentifier=()=>{const user=getStoredUser();return(user===null||user===void 0?void 0:user.phone)||(user===null||user===void 0?void 0:user.user_id)||null;};/**\r\n * Get credentials for CURRENT user only\r\n */const getUserCredentials=()=>{const userId=getCurrentUserIdentifier();if(!userId)return[];const allCredentials=JSON.parse(window.localStorage.getItem('fdt_credentials')||'{}');return allCredentials[userId]||[];};/**\r\n * Save credential for CURRENT user only\r\n */const saveUserCredential=credential=>{const userId=getCurrentUserIdentifier();if(!userId){console.warn('Cannot save credential - no user identifier');return;}const allCredentials=JSON.parse(window.localStorage.getItem('fdt_credentials')||'{}');if(!allCredentials[userId]){allCredentials[userId]=[];}allCredentials[userId].push(credential);window.localStorage.setItem('fdt_credentials',JSON.stringify(allCredentials));};/**\r\n * Remove credential for CURRENT user only\r\n */const removeUserCredential=credentialId=>{const userId=getCurrentUserIdentifier();if(!userId)return;const allCredentials=JSON.parse(window.localStorage.getItem('fdt_credentials')||'{}');if(allCredentials[userId]){allCredentials[userId]=allCredentials[userId].filter(c=>c.id!==credentialId);window.localStorage.setItem('fdt_credentials',JSON.stringify(allCredentials));}};// â”€â”€â”€ Registration â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n/**\r\n * Register a new biometric credential for the CURRENT user\r\n * @param {string|null} deviceName\r\n * @returns {Promise<Object>}\r\n */export const registerBiometric=async function(){let deviceName=arguments.length>0&&arguments[0]!==undefined?arguments[0]:null;if(!isWebAuthnSupported())throw new Error('WebAuthn is not supported in this browser');const available=await isPlatformAuthenticatorAvailable();if(!available)throw new Error('No biometric authenticator available on this device');const token=getAuthToken();console.log('ğŸ” Token check:',{hasToken:!!token,tokenLength:token===null||token===void 0?void 0:token.length});if(!token)throw new Error('User not authenticated â€“ please log in again');try{// Step 1: Get registration options from backend\nconsole.log('ğŸ“± Requesting biometric registration options...');const optionsResponse=await fetch(\"\".concat(BACKEND_URL,\"/auth/biometric/register/options\"),{method:'POST',headers:{Authorization:\"Bearer \".concat(token),'Content-Type':'application/json'}});if(!optionsResponse.ok){const errorData=await optionsResponse.json().catch(()=>({}));const errorMsg=errorData.detail||\"HTTP \".concat(optionsResponse.status,\" \\u2013 Failed to get registration options\");console.error('âŒ Options endpoint error:',{status:optionsResponse.status,error:errorMsg});throw new Error(errorMsg);}const optionsData=await optionsResponse.json();const options=optionsData.options;console.log('âœ“ Received registration options with challenge:',options.challenge.substring(0,20)+'...');// Step 2: Create credential on device (IMMEDIATELY - don't wait)\nconst publicKeyOptions={challenge:base64urlToBuffer(options.challenge),rp:{id:options.rp.id,name:options.rp.name},user:{id:new TextEncoder().encode(options.user.id),name:options.user.name,displayName:options.user.displayName||options.user.name||'User'},pubKeyCredParams:options.pubKeyCredParams,authenticatorSelection:{authenticatorAttachment:'platform',residentKey:'preferred',userVerification:'preferred'},timeout:120000,// 2 minutes instead of 60 seconds\nattestation:options.attestation||'direct'};console.log('ğŸ” Requesting biometric credential creation (user will be prompted)...');const credential=await navigator.credentials.create({publicKey:publicKeyOptions});if(!credential){throw new Error('User cancelled biometric registration or credential creation failed');}console.log('âœ… Credential created, ID:',bufferToBase64url(credential.rawId).substring(0,20)+'...');// Step 3: Verify credential with backend IMMEDIATELY\nconsole.log('ğŸ“¤ Verifying credential with backend...');const verifyResponse=await fetch(\"\".concat(BACKEND_URL,\"/auth/biometric/register/verify\"),{method:'POST',headers:{Authorization:\"Bearer \".concat(token),'Content-Type':'application/json'},body:JSON.stringify({credential_id:bufferToBase64url(credential.rawId),attestation_object:bufferToBase64url(credential.response.attestationObject),client_data_json:bufferToBase64url(credential.response.clientDataJSON),device_name:deviceName})});if(!verifyResponse.ok){const error=await verifyResponse.json();throw new Error(extractErrorDetail(error,'Credential verification failed'));}const result=await verifyResponse.json();console.log('âœ… Biometric credential registered successfully:',result);// Store credential for THIS USER ONLY (using phone/user_id as key)\nsaveUserCredential({id:bufferToBase64url(credential.rawId),name:deviceName||result.device_name,created:new Date().toISOString()});return result;}catch(error){console.error('âŒ Biometric registration failed:',error);throw error;}};/**\r\n * Authenticate using biometric for the CURRENT user\r\n * @returns {Promise<Object>}\r\n * @throws {Error} with friendly message if authentication fails\r\n */export const authenticateWithBiometric=async()=>{// Validate support\nif(!isWebAuthnSupported()){throw new Error('WebAuthn is not supported in this browser');}// Get current user\nconst user=getStoredUser();const userId=(user===null||user===void 0?void 0:user.phone)||(user===null||user===void 0?void 0:user.user_id);if(!userId){console.warn('âš ï¸ No user context for biometric auth');throw new Error('User session required. Please log in again.');}// Check rate limiting\nif(attemptTracker.isLocked(userId)){const lockoutMin=SECURITY_CONFIG.RETRY_LOCKOUT_MINUTES;throw new Error(\"Too many failed attempts. Try again in \".concat(lockoutMin,\" minutes.\"));}try{var _challengeData$option;// Step 1: Get authentication challenge\nconsole.log('ğŸ“± Requesting biometric authentication challenge...');const challengeResponse=await fetch(\"\".concat(BACKEND_URL,\"/auth/biometric/authenticate/options\"),{method:'POST',headers:{'Content-Type':'application/json'},signal:AbortSignal.timeout(SECURITY_CONFIG.CHALLENGE_TIMEOUT_MS)// Abort if too slow\n});if(!challengeResponse.ok){const error=await challengeResponse.json().catch(()=>({}));throw new Error(extractErrorDetail(error,\"Server error: \".concat(challengeResponse.status)));}const challengeData=await challengeResponse.json();if(!((_challengeData$option=challengeData.options)!==null&&_challengeData$option!==void 0&&_challengeData$option.challenge)){throw new Error('Invalid challenge from server');}const options=challengeData.options;console.log('âœ“ Challenge received:',options.challenge.substring(0,10)+'...');// Step 2: Get assertion from device with timeout\nconsole.log('ğŸ” Requesting biometric verification...');const assertion=await navigator.credentials.get({publicKey:{challenge:base64urlToBuffer(options.challenge),timeout:SECURITY_CONFIG.AUTH_TIMEOUT_MS,userVerification:options.userVerification||'preferred',mediation:'optional'}});if(!assertion){attemptTracker.recordAttempt(userId);throw new Error('User cancelled biometric authentication');}console.log('âœ“ Biometric verified, credentialId:',bufferToBase64url(assertion.rawId).substring(0,10)+'...');// Step 3: Verify assertion with backend\nconsole.log('ğŸ“¤ Verifying assertion with server...');const verifyResponse=await fetch(\"\".concat(BACKEND_URL,\"/auth/biometric/authenticate/verify\"),{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({credential_id:bufferToBase64url(assertion.rawId),authenticator_data:bufferToBase64url(assertion.response.authenticatorData),client_data_json:bufferToBase64url(assertion.response.clientDataJSON),signature:bufferToBase64url(assertion.response.signature)}),signal:AbortSignal.timeout(SECURITY_CONFIG.CHALLENGE_TIMEOUT_MS)});if(!verifyResponse.ok){attemptTracker.recordAttempt(userId);const error=await verifyResponse.json().catch(()=>({}));throw new Error(extractErrorDetail(error,'Authentication verification failed'));}const result=await verifyResponse.json();console.log('âœ… Biometric authentication successful');// Reset attempts on success\nattemptTracker.reset(userId);// Store token and user\nif(result.token){setAuthToken(result.token);console.log('âœ“ Token stored securely');}if(result.user){setStoredUser(result.user);console.log('âœ“ User data updated');}return result;}catch(error){// Convert to user-friendly message\nconst friendlyError=typeof error.message==='string'?getUserFriendlyError(error,'authentication'):extractErrorDetail(error,'Authentication failed');console.error('âŒ Biometric authentication error:',friendlyError);throw new Error(friendlyError);}};// â”€â”€â”€ Credential Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n/**\r\n * Check if CURRENT user has stored credentials\r\n */export const hasStoredCredentials=()=>{const credentials=getUserCredentials();return credentials.length>0;};/**\r\n * Get registered credentials for CURRENT user from server\r\n */export const getRegisteredCredentials=async()=>{const token=getAuthToken();if(!token)throw new Error('User not authenticated');console.log('ğŸ”‘ Fetching registered credentials...');const response=await fetch(\"\".concat(BACKEND_URL,\"/api/auth/credentials\"),{method:'GET',headers:{Authorization:\"Bearer \".concat(token),'Content-Type':'application/json'}});console.log('ğŸ“¡ Response status:',response.status);if(!response.ok)throw new Error('Failed to fetch credentials');const data=await response.json();const credentials=data.credentials||[];console.log('âœ… Loaded',credentials.length,'credentials');return credentials;};/**\r\n * Revoke a credential for CURRENT user\r\n */export const revokeCredential=async credentialId=>{const token=getAuthToken();if(!token)throw new Error('User not authenticated');const response=await fetch(\"\".concat(BACKEND_URL,\"/api/auth/credentials/\").concat(encodeURIComponent(credentialId)),{method:'DELETE',headers:{Authorization:\"Bearer \".concat(token),'Content-Type':'application/json'}});if(!response.ok){const error=await response.json();throw new Error(extractErrorDetail(error,'Failed to revoke credential'));}const result=await response.json();// Remove from sessionStorage for THIS USER ONLY\nremoveUserCredential(credentialId);return result;};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}