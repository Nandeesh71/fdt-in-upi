{"ast":null,"code":"import{useEffect,useRef}from'react';import{Scene,OrthographicCamera,WebGLRenderer,PlaneGeometry,Mesh,ShaderMaterial,Vector3,Vector2,Clock}from'three';import'./FloatingLines.css';import{jsx as _jsx}from\"react/jsx-runtime\";const vertexShader=\"\\nprecision highp float;\\n\\nvoid main() {\\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\\n}\\n\";const fragmentShader=\"\\nprecision highp float;\\n\\nuniform float iTime;\\nuniform vec3  iResolution;\\nuniform float animationSpeed;\\n\\nuniform bool enableTop;\\nuniform bool enableMiddle;\\nuniform bool enableBottom;\\n\\nuniform int topLineCount;\\nuniform int middleLineCount;\\nuniform int bottomLineCount;\\n\\nuniform float topLineDistance;\\nuniform float middleLineDistance;\\nuniform float bottomLineDistance;\\n\\nuniform vec3 topWavePosition;\\nuniform vec3 middleWavePosition;\\nuniform vec3 bottomWavePosition;\\n\\nuniform vec2 iMouse;\\nuniform bool interactive;\\nuniform float bendRadius;\\nuniform float bendStrength;\\nuniform float bendInfluence;\\n\\nuniform bool parallax;\\nuniform float parallaxStrength;\\nuniform vec2 parallaxOffset;\\n\\nuniform vec3 lineGradient[8];\\nuniform int lineGradientCount;\\n\\nconst vec3 BLACK = vec3(0.0);\\nconst vec3 PINK  = vec3(233.0, 71.0, 245.0) / 255.0;\\nconst vec3 BLUE  = vec3(47.0,  75.0, 162.0) / 255.0;\\n\\nmat2 rotate(float r) {\\n  return mat2(cos(r), sin(r), -sin(r), cos(r));\\n}\\n\\nvec3 background_color(vec2 uv) {\\n  vec3 col = vec3(0.0);\\n\\n  float y = sin(uv.x - 0.2) * 0.3 - 0.1;\\n  float m = uv.y - y;\\n\\n  col += mix(BLUE, BLACK, smoothstep(0.0, 1.0, abs(m)));\\n  col += mix(PINK, BLACK, smoothstep(0.0, 1.0, abs(m - 0.8)));\\n  return col * 0.5;\\n}\\n\\nvec3 getLineColor(float t, vec3 baseColor) {\\n  if (lineGradientCount <= 0) {\\n    return baseColor;\\n  }\\n\\n  vec3 gradientColor;\\n  \\n  if (lineGradientCount == 1) {\\n    gradientColor = lineGradient[0];\\n  } else {\\n    float clampedT = clamp(t, 0.0, 0.9999);\\n    float scaled = clampedT * float(lineGradientCount - 1);\\n    int idx = int(floor(scaled));\\n    float f = fract(scaled);\\n    int idx2 = min(idx + 1, lineGradientCount - 1);\\n\\n    vec3 c1 = lineGradient[idx];\\n    vec3 c2 = lineGradient[idx2];\\n    \\n    gradientColor = mix(c1, c2, f);\\n  }\\n  \\n  return gradientColor * 0.5;\\n}\\n\\n  float wave(vec2 uv, float offset, vec2 screenUv, vec2 mouseUv, bool shouldBend) {\\n  float time = iTime * animationSpeed;\\n\\n  float x_offset   = offset;\\n  float x_movement = time * 0.1;\\n  float amp        = sin(offset + time * 0.2) * 0.3;\\n  float y          = sin(uv.x + x_offset + x_movement) * amp;\\n\\n  if (shouldBend) {\\n    vec2 d = screenUv - mouseUv;\\n    float influence = exp(-dot(d, d) * bendRadius); // radial falloff around cursor\\n    float bendOffset = (mouseUv.y - screenUv.y) * influence * bendStrength * bendInfluence;\\n    y += bendOffset;\\n  }\\n\\n  float m = uv.y - y;\\n  return 0.0175 / max(abs(m) + 0.01, 1e-3) + 0.01;\\n}\\n\\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\\n  vec2 baseUv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\\n  baseUv.y *= -1.0;\\n  \\n  if (parallax) {\\n    baseUv += parallaxOffset;\\n  }\\n\\n  vec3 col = vec3(0.0);\\n\\n  vec3 b = lineGradientCount > 0 ? vec3(0.0) : background_color(baseUv);\\n\\n  vec2 mouseUv = vec2(0.0);\\n  if (interactive) {\\n    mouseUv = (2.0 * iMouse - iResolution.xy) / iResolution.y;\\n    mouseUv.y *= -1.0;\\n  }\\n  \\n  if (enableBottom) {\\n    for (int i = 0; i < bottomLineCount; ++i) {\\n      float fi = float(i);\\n      float t = fi / max(float(bottomLineCount - 1), 1.0);\\n      vec3 lineCol = getLineColor(t, b);\\n      \\n      float angle = bottomWavePosition.z * log(length(baseUv) + 1.0);\\n      vec2 ruv = baseUv * rotate(angle);\\n      col += lineCol * wave(\\n        ruv + vec2(bottomLineDistance * fi + bottomWavePosition.x, bottomWavePosition.y),\\n        1.5 + 0.2 * fi,\\n        baseUv,\\n        mouseUv,\\n        interactive\\n      ) * 0.2;\\n    }\\n  }\\n\\n  if (enableMiddle) {\\n    for (int i = 0; i < middleLineCount; ++i) {\\n      float fi = float(i);\\n      float t = fi / max(float(middleLineCount - 1), 1.0);\\n      vec3 lineCol = getLineColor(t, b);\\n      \\n      float angle = middleWavePosition.z * log(length(baseUv) + 1.0);\\n      vec2 ruv = baseUv * rotate(angle);\\n      col += lineCol * wave(\\n        ruv + vec2(middleLineDistance * fi + middleWavePosition.x, middleWavePosition.y),\\n        2.0 + 0.15 * fi,\\n        baseUv,\\n        mouseUv,\\n        interactive\\n      );\\n    }\\n  }\\n\\n  if (enableTop) {\\n    for (int i = 0; i < topLineCount; ++i) {\\n      float fi = float(i);\\n      float t = fi / max(float(topLineCount - 1), 1.0);\\n      vec3 lineCol = getLineColor(t, b);\\n      \\n      float angle = topWavePosition.z * log(length(baseUv) + 1.0);\\n      vec2 ruv = baseUv * rotate(angle);\\n      ruv.x *= -1.0;\\n      col += lineCol * wave(\\n        ruv + vec2(topLineDistance * fi + topWavePosition.x, topWavePosition.y),\\n        1.0 + 0.2 * fi,\\n        baseUv,\\n        mouseUv,\\n        interactive\\n      ) * 0.1;\\n    }\\n  }\\n\\n  fragColor = vec4(col, 1.0);\\n}\\n\\nvoid main() {\\n  vec4 color = vec4(0.0);\\n  mainImage(color, gl_FragCoord.xy);\\n  gl_FragColor = color;\\n}\\n\";const MAX_GRADIENT_STOPS=8;function hexToVec3(hex){let value=hex.trim();if(value.startsWith('#')){value=value.slice(1);}let r=255;let g=255;let b=255;if(value.length===3){r=parseInt(value[0]+value[0],16);g=parseInt(value[1]+value[1],16);b=parseInt(value[2]+value[2],16);}else if(value.length===6){r=parseInt(value.slice(0,2),16);g=parseInt(value.slice(2,4),16);b=parseInt(value.slice(4,6),16);}return new Vector3(r/255,g/255,b/255);}export default function FloatingLines(_ref){let{linesGradient,enabledWaves=['top','middle','bottom'],lineCount=[6],lineDistance=[5],topWavePosition,middleWavePosition,bottomWavePosition={x:2.0,y:-0.7,rotate:-1},animationSpeed=1,interactive=true,bendRadius=5.0,bendStrength=-0.5,mouseDamping=0.05,parallax=true,parallaxStrength=0.2,mixBlendMode='screen'}=_ref;const containerRef=useRef(null);const targetMouseRef=useRef(new Vector2(-1000,-1000));const currentMouseRef=useRef(new Vector2(-1000,-1000));const targetInfluenceRef=useRef(0);const currentInfluenceRef=useRef(0);const targetParallaxRef=useRef(new Vector2(0,0));const currentParallaxRef=useRef(new Vector2(0,0));useEffect(()=>{var _topWavePosition$x,_topWavePosition$y,_topWavePosition$rota,_middleWavePosition$x,_middleWavePosition$y,_middleWavePosition$r,_bottomWavePosition$x,_bottomWavePosition$y,_bottomWavePosition$r;if(!containerRef.current)return;// Helper functions\nconst getLineCount=waveType=>{var _lineCount$index;if(typeof lineCount==='number')return lineCount;if(!enabledWaves.includes(waveType))return 0;const index=enabledWaves.indexOf(waveType);return(_lineCount$index=lineCount[index])!==null&&_lineCount$index!==void 0?_lineCount$index:6;};const getLineDistance=waveType=>{var _lineDistance$index;if(typeof lineDistance==='number')return lineDistance;if(!enabledWaves.includes(waveType))return 0.1;const index=enabledWaves.indexOf(waveType);return(_lineDistance$index=lineDistance[index])!==null&&_lineDistance$index!==void 0?_lineDistance$index:0.1;};// Calculate line counts and distances inside effect\nconst topLineCount=enabledWaves.includes('top')?getLineCount('top'):0;const middleLineCount=enabledWaves.includes('middle')?getLineCount('middle'):0;const bottomLineCount=enabledWaves.includes('bottom')?getLineCount('bottom'):0;const topLineDistance=enabledWaves.includes('top')?getLineDistance('top')*0.01:0.01;const middleLineDistance=enabledWaves.includes('middle')?getLineDistance('middle')*0.01:0.01;const bottomLineDistance=enabledWaves.includes('bottom')?getLineDistance('bottom')*0.01:0.01;const scene=new Scene();const camera=new OrthographicCamera(-1,1,1,-1,0,1);camera.position.z=1;const renderer=new WebGLRenderer({antialias:true,alpha:false});renderer.setPixelRatio(Math.min(window.devicePixelRatio||1,2));renderer.domElement.style.width='100%';renderer.domElement.style.height='100%';containerRef.current.appendChild(renderer.domElement);const uniforms={iTime:{value:0},iResolution:{value:new Vector3(1,1,1)},animationSpeed:{value:animationSpeed},enableTop:{value:enabledWaves.includes('top')},enableMiddle:{value:enabledWaves.includes('middle')},enableBottom:{value:enabledWaves.includes('bottom')},topLineCount:{value:topLineCount},middleLineCount:{value:middleLineCount},bottomLineCount:{value:bottomLineCount},topLineDistance:{value:topLineDistance},middleLineDistance:{value:middleLineDistance},bottomLineDistance:{value:bottomLineDistance},topWavePosition:{value:new Vector3((_topWavePosition$x=topWavePosition===null||topWavePosition===void 0?void 0:topWavePosition.x)!==null&&_topWavePosition$x!==void 0?_topWavePosition$x:10.0,(_topWavePosition$y=topWavePosition===null||topWavePosition===void 0?void 0:topWavePosition.y)!==null&&_topWavePosition$y!==void 0?_topWavePosition$y:0.5,(_topWavePosition$rota=topWavePosition===null||topWavePosition===void 0?void 0:topWavePosition.rotate)!==null&&_topWavePosition$rota!==void 0?_topWavePosition$rota:-0.4)},middleWavePosition:{value:new Vector3((_middleWavePosition$x=middleWavePosition===null||middleWavePosition===void 0?void 0:middleWavePosition.x)!==null&&_middleWavePosition$x!==void 0?_middleWavePosition$x:5.0,(_middleWavePosition$y=middleWavePosition===null||middleWavePosition===void 0?void 0:middleWavePosition.y)!==null&&_middleWavePosition$y!==void 0?_middleWavePosition$y:0.0,(_middleWavePosition$r=middleWavePosition===null||middleWavePosition===void 0?void 0:middleWavePosition.rotate)!==null&&_middleWavePosition$r!==void 0?_middleWavePosition$r:0.2)},bottomWavePosition:{value:new Vector3((_bottomWavePosition$x=bottomWavePosition===null||bottomWavePosition===void 0?void 0:bottomWavePosition.x)!==null&&_bottomWavePosition$x!==void 0?_bottomWavePosition$x:2.0,(_bottomWavePosition$y=bottomWavePosition===null||bottomWavePosition===void 0?void 0:bottomWavePosition.y)!==null&&_bottomWavePosition$y!==void 0?_bottomWavePosition$y:-0.7,(_bottomWavePosition$r=bottomWavePosition===null||bottomWavePosition===void 0?void 0:bottomWavePosition.rotate)!==null&&_bottomWavePosition$r!==void 0?_bottomWavePosition$r:0.4)},iMouse:{value:new Vector2(-1000,-1000)},interactive:{value:interactive},bendRadius:{value:bendRadius},bendStrength:{value:bendStrength},bendInfluence:{value:0},parallax:{value:parallax},parallaxStrength:{value:parallaxStrength},parallaxOffset:{value:new Vector2(0,0)},lineGradient:{value:Array.from({length:MAX_GRADIENT_STOPS},()=>new Vector3(1,1,1))},lineGradientCount:{value:0}};if(linesGradient&&linesGradient.length>0){const stops=linesGradient.slice(0,MAX_GRADIENT_STOPS);uniforms.lineGradientCount.value=stops.length;stops.forEach((hex,i)=>{const color=hexToVec3(hex);uniforms.lineGradient.value[i].set(color.x,color.y,color.z);});}const material=new ShaderMaterial({uniforms,vertexShader,fragmentShader});const geometry=new PlaneGeometry(2,2);const mesh=new Mesh(geometry,material);scene.add(mesh);const clock=new Clock();const setSize=()=>{const el=containerRef.current;if(!el){return;}const width=el.clientWidth||1;const height=el.clientHeight||1;renderer.setSize(width,height,false);const canvasWidth=renderer.domElement.width;const canvasHeight=renderer.domElement.height;uniforms.iResolution.value.set(canvasWidth,canvasHeight,1);};setSize();const ro=typeof ResizeObserver!=='undefined'?new ResizeObserver(setSize):null;if(ro&&containerRef.current){ro.observe(containerRef.current);}const handlePointerMove=event=>{const rect=renderer.domElement.getBoundingClientRect();const x=event.clientX-rect.left;const y=event.clientY-rect.top;const dpr=renderer.getPixelRatio();targetMouseRef.current.set(x*dpr,(rect.height-y)*dpr);targetInfluenceRef.current=1.0;if(parallax){const centerX=rect.width/2;const centerY=rect.height/2;const offsetX=(x-centerX)/rect.width;const offsetY=-(y-centerY)/rect.height;targetParallaxRef.current.set(offsetX*parallaxStrength,offsetY*parallaxStrength);}};const handlePointerLeave=()=>{targetInfluenceRef.current=0.0;};if(interactive){renderer.domElement.addEventListener('pointermove',handlePointerMove);renderer.domElement.addEventListener('pointerleave',handlePointerLeave);}let raf=0;const renderLoop=()=>{uniforms.iTime.value=clock.getElapsedTime();if(interactive){currentMouseRef.current.lerp(targetMouseRef.current,mouseDamping);uniforms.iMouse.value.copy(currentMouseRef.current);currentInfluenceRef.current+=(targetInfluenceRef.current-currentInfluenceRef.current)*mouseDamping;uniforms.bendInfluence.value=currentInfluenceRef.current;}if(parallax){currentParallaxRef.current.lerp(targetParallaxRef.current,mouseDamping);uniforms.parallaxOffset.value.copy(currentParallaxRef.current);}renderer.render(scene,camera);raf=requestAnimationFrame(renderLoop);};renderLoop();const container=containerRef.current;return()=>{cancelAnimationFrame(raf);if(ro&&container){ro.disconnect();}if(interactive){renderer.domElement.removeEventListener('pointermove',handlePointerMove);renderer.domElement.removeEventListener('pointerleave',handlePointerLeave);}geometry.dispose();material.dispose();renderer.dispose();if(renderer.domElement.parentElement){renderer.domElement.parentElement.removeChild(renderer.domElement);}};},[linesGradient,enabledWaves,lineCount,lineDistance,topWavePosition,middleWavePosition,bottomWavePosition,animationSpeed,interactive,bendRadius,bendStrength,mouseDamping,parallax,parallaxStrength]);return/*#__PURE__*/_jsx(\"div\",{ref:containerRef,className:\"floating-lines-container\",style:{mixBlendMode:mixBlendMode}});}","map":{"version":3,"names":["useEffect","useRef","Scene","OrthographicCamera","WebGLRenderer","PlaneGeometry","Mesh","ShaderMaterial","Vector3","Vector2","Clock","jsx","_jsx","vertexShader","fragmentShader","MAX_GRADIENT_STOPS","hexToVec3","hex","value","trim","startsWith","slice","r","g","b","length","parseInt","FloatingLines","_ref","linesGradient","enabledWaves","lineCount","lineDistance","topWavePosition","middleWavePosition","bottomWavePosition","x","y","rotate","animationSpeed","interactive","bendRadius","bendStrength","mouseDamping","parallax","parallaxStrength","mixBlendMode","containerRef","targetMouseRef","currentMouseRef","targetInfluenceRef","currentInfluenceRef","targetParallaxRef","currentParallaxRef","_topWavePosition$x","_topWavePosition$y","_topWavePosition$rota","_middleWavePosition$x","_middleWavePosition$y","_middleWavePosition$r","_bottomWavePosition$x","_bottomWavePosition$y","_bottomWavePosition$r","current","getLineCount","waveType","_lineCount$index","includes","index","indexOf","getLineDistance","_lineDistance$index","topLineCount","middleLineCount","bottomLineCount","topLineDistance","middleLineDistance","bottomLineDistance","scene","camera","position","z","renderer","antialias","alpha","setPixelRatio","Math","min","window","devicePixelRatio","domElement","style","width","height","appendChild","uniforms","iTime","iResolution","enableTop","enableMiddle","enableBottom","iMouse","bendInfluence","parallaxOffset","lineGradient","Array","from","lineGradientCount","stops","forEach","i","color","set","material","geometry","mesh","add","clock","setSize","el","clientWidth","clientHeight","canvasWidth","canvasHeight","ro","ResizeObserver","observe","handlePointerMove","event","rect","getBoundingClientRect","clientX","left","clientY","top","dpr","getPixelRatio","centerX","centerY","offsetX","offsetY","handlePointerLeave","addEventListener","raf","renderLoop","getElapsedTime","lerp","copy","render","requestAnimationFrame","container","cancelAnimationFrame","disconnect","removeEventListener","dispose","parentElement","removeChild","ref","className"],"sources":["/home/aakash/Projects/Fraud-Detection-in-UPI---FDT2/frontend/src/components/FloatingLines.js"],"sourcesContent":["import { useEffect, useRef } from 'react';\nimport {\n  Scene,\n  OrthographicCamera,\n  WebGLRenderer,\n  PlaneGeometry,\n  Mesh,\n  ShaderMaterial,\n  Vector3,\n  Vector2,\n  Clock\n} from 'three';\n\nimport './FloatingLines.css';\n\nconst vertexShader = `\nprecision highp float;\n\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n`;\n\nconst fragmentShader = `\nprecision highp float;\n\nuniform float iTime;\nuniform vec3  iResolution;\nuniform float animationSpeed;\n\nuniform bool enableTop;\nuniform bool enableMiddle;\nuniform bool enableBottom;\n\nuniform int topLineCount;\nuniform int middleLineCount;\nuniform int bottomLineCount;\n\nuniform float topLineDistance;\nuniform float middleLineDistance;\nuniform float bottomLineDistance;\n\nuniform vec3 topWavePosition;\nuniform vec3 middleWavePosition;\nuniform vec3 bottomWavePosition;\n\nuniform vec2 iMouse;\nuniform bool interactive;\nuniform float bendRadius;\nuniform float bendStrength;\nuniform float bendInfluence;\n\nuniform bool parallax;\nuniform float parallaxStrength;\nuniform vec2 parallaxOffset;\n\nuniform vec3 lineGradient[8];\nuniform int lineGradientCount;\n\nconst vec3 BLACK = vec3(0.0);\nconst vec3 PINK  = vec3(233.0, 71.0, 245.0) / 255.0;\nconst vec3 BLUE  = vec3(47.0,  75.0, 162.0) / 255.0;\n\nmat2 rotate(float r) {\n  return mat2(cos(r), sin(r), -sin(r), cos(r));\n}\n\nvec3 background_color(vec2 uv) {\n  vec3 col = vec3(0.0);\n\n  float y = sin(uv.x - 0.2) * 0.3 - 0.1;\n  float m = uv.y - y;\n\n  col += mix(BLUE, BLACK, smoothstep(0.0, 1.0, abs(m)));\n  col += mix(PINK, BLACK, smoothstep(0.0, 1.0, abs(m - 0.8)));\n  return col * 0.5;\n}\n\nvec3 getLineColor(float t, vec3 baseColor) {\n  if (lineGradientCount <= 0) {\n    return baseColor;\n  }\n\n  vec3 gradientColor;\n  \n  if (lineGradientCount == 1) {\n    gradientColor = lineGradient[0];\n  } else {\n    float clampedT = clamp(t, 0.0, 0.9999);\n    float scaled = clampedT * float(lineGradientCount - 1);\n    int idx = int(floor(scaled));\n    float f = fract(scaled);\n    int idx2 = min(idx + 1, lineGradientCount - 1);\n\n    vec3 c1 = lineGradient[idx];\n    vec3 c2 = lineGradient[idx2];\n    \n    gradientColor = mix(c1, c2, f);\n  }\n  \n  return gradientColor * 0.5;\n}\n\n  float wave(vec2 uv, float offset, vec2 screenUv, vec2 mouseUv, bool shouldBend) {\n  float time = iTime * animationSpeed;\n\n  float x_offset   = offset;\n  float x_movement = time * 0.1;\n  float amp        = sin(offset + time * 0.2) * 0.3;\n  float y          = sin(uv.x + x_offset + x_movement) * amp;\n\n  if (shouldBend) {\n    vec2 d = screenUv - mouseUv;\n    float influence = exp(-dot(d, d) * bendRadius); // radial falloff around cursor\n    float bendOffset = (mouseUv.y - screenUv.y) * influence * bendStrength * bendInfluence;\n    y += bendOffset;\n  }\n\n  float m = uv.y - y;\n  return 0.0175 / max(abs(m) + 0.01, 1e-3) + 0.01;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 baseUv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n  baseUv.y *= -1.0;\n  \n  if (parallax) {\n    baseUv += parallaxOffset;\n  }\n\n  vec3 col = vec3(0.0);\n\n  vec3 b = lineGradientCount > 0 ? vec3(0.0) : background_color(baseUv);\n\n  vec2 mouseUv = vec2(0.0);\n  if (interactive) {\n    mouseUv = (2.0 * iMouse - iResolution.xy) / iResolution.y;\n    mouseUv.y *= -1.0;\n  }\n  \n  if (enableBottom) {\n    for (int i = 0; i < bottomLineCount; ++i) {\n      float fi = float(i);\n      float t = fi / max(float(bottomLineCount - 1), 1.0);\n      vec3 lineCol = getLineColor(t, b);\n      \n      float angle = bottomWavePosition.z * log(length(baseUv) + 1.0);\n      vec2 ruv = baseUv * rotate(angle);\n      col += lineCol * wave(\n        ruv + vec2(bottomLineDistance * fi + bottomWavePosition.x, bottomWavePosition.y),\n        1.5 + 0.2 * fi,\n        baseUv,\n        mouseUv,\n        interactive\n      ) * 0.2;\n    }\n  }\n\n  if (enableMiddle) {\n    for (int i = 0; i < middleLineCount; ++i) {\n      float fi = float(i);\n      float t = fi / max(float(middleLineCount - 1), 1.0);\n      vec3 lineCol = getLineColor(t, b);\n      \n      float angle = middleWavePosition.z * log(length(baseUv) + 1.0);\n      vec2 ruv = baseUv * rotate(angle);\n      col += lineCol * wave(\n        ruv + vec2(middleLineDistance * fi + middleWavePosition.x, middleWavePosition.y),\n        2.0 + 0.15 * fi,\n        baseUv,\n        mouseUv,\n        interactive\n      );\n    }\n  }\n\n  if (enableTop) {\n    for (int i = 0; i < topLineCount; ++i) {\n      float fi = float(i);\n      float t = fi / max(float(topLineCount - 1), 1.0);\n      vec3 lineCol = getLineColor(t, b);\n      \n      float angle = topWavePosition.z * log(length(baseUv) + 1.0);\n      vec2 ruv = baseUv * rotate(angle);\n      ruv.x *= -1.0;\n      col += lineCol * wave(\n        ruv + vec2(topLineDistance * fi + topWavePosition.x, topWavePosition.y),\n        1.0 + 0.2 * fi,\n        baseUv,\n        mouseUv,\n        interactive\n      ) * 0.1;\n    }\n  }\n\n  fragColor = vec4(col, 1.0);\n}\n\nvoid main() {\n  vec4 color = vec4(0.0);\n  mainImage(color, gl_FragCoord.xy);\n  gl_FragColor = color;\n}\n`;\n\nconst MAX_GRADIENT_STOPS = 8;\n\nfunction hexToVec3(hex) {\n  let value = hex.trim();\n\n  if (value.startsWith('#')) {\n    value = value.slice(1);\n  }\n\n  let r = 255;\n  let g = 255;\n  let b = 255;\n\n  if (value.length === 3) {\n    r = parseInt(value[0] + value[0], 16);\n    g = parseInt(value[1] + value[1], 16);\n    b = parseInt(value[2] + value[2], 16);\n  } else if (value.length === 6) {\n    r = parseInt(value.slice(0, 2), 16);\n    g = parseInt(value.slice(2, 4), 16);\n    b = parseInt(value.slice(4, 6), 16);\n  }\n\n  return new Vector3(r / 255, g / 255, b / 255);\n}\n\nexport default function FloatingLines({\n  linesGradient,\n  enabledWaves = ['top', 'middle', 'bottom'],\n  lineCount = [6],\n  lineDistance = [5],\n  topWavePosition,\n  middleWavePosition,\n  bottomWavePosition = { x: 2.0, y: -0.7, rotate: -1 },\n  animationSpeed = 1,\n  interactive = true,\n  bendRadius = 5.0,\n  bendStrength = -0.5,\n  mouseDamping = 0.05,\n  parallax = true,\n  parallaxStrength = 0.2,\n  mixBlendMode = 'screen'\n}) {\n  const containerRef = useRef(null);\n  const targetMouseRef = useRef(new Vector2(-1000, -1000));\n  const currentMouseRef = useRef(new Vector2(-1000, -1000));\n  const targetInfluenceRef = useRef(0);\n  const currentInfluenceRef = useRef(0);\n  const targetParallaxRef = useRef(new Vector2(0, 0));\n  const currentParallaxRef = useRef(new Vector2(0, 0));\n\n  useEffect(() => {\n    if (!containerRef.current) return;\n\n    // Helper functions\n    const getLineCount = waveType => {\n      if (typeof lineCount === 'number') return lineCount;\n      if (!enabledWaves.includes(waveType)) return 0;\n      const index = enabledWaves.indexOf(waveType);\n      return lineCount[index] ?? 6;\n    };\n\n    const getLineDistance = waveType => {\n      if (typeof lineDistance === 'number') return lineDistance;\n      if (!enabledWaves.includes(waveType)) return 0.1;\n      const index = enabledWaves.indexOf(waveType);\n      return lineDistance[index] ?? 0.1;\n    };\n\n    // Calculate line counts and distances inside effect\n    const topLineCount = enabledWaves.includes('top') ? getLineCount('top') : 0;\n    const middleLineCount = enabledWaves.includes('middle') ? getLineCount('middle') : 0;\n    const bottomLineCount = enabledWaves.includes('bottom') ? getLineCount('bottom') : 0;\n\n    const topLineDistance = enabledWaves.includes('top') ? getLineDistance('top') * 0.01 : 0.01;\n    const middleLineDistance = enabledWaves.includes('middle') ? getLineDistance('middle') * 0.01 : 0.01;\n    const bottomLineDistance = enabledWaves.includes('bottom') ? getLineDistance('bottom') * 0.01 : 0.01;\n\n    const scene = new Scene();\n\n    const camera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);\n    camera.position.z = 1;\n\n    const renderer = new WebGLRenderer({ antialias: true, alpha: false });\n    renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));\n    renderer.domElement.style.width = '100%';\n    renderer.domElement.style.height = '100%';\n    containerRef.current.appendChild(renderer.domElement);\n\n    const uniforms = {\n      iTime: { value: 0 },\n      iResolution: { value: new Vector3(1, 1, 1) },\n      animationSpeed: { value: animationSpeed },\n\n      enableTop: { value: enabledWaves.includes('top') },\n      enableMiddle: { value: enabledWaves.includes('middle') },\n      enableBottom: { value: enabledWaves.includes('bottom') },\n\n      topLineCount: { value: topLineCount },\n      middleLineCount: { value: middleLineCount },\n      bottomLineCount: { value: bottomLineCount },\n\n      topLineDistance: { value: topLineDistance },\n      middleLineDistance: { value: middleLineDistance },\n      bottomLineDistance: { value: bottomLineDistance },\n\n      topWavePosition: {\n        value: new Vector3(topWavePosition?.x ?? 10.0, topWavePosition?.y ?? 0.5, topWavePosition?.rotate ?? -0.4)\n      },\n      middleWavePosition: {\n        value: new Vector3(\n          middleWavePosition?.x ?? 5.0,\n          middleWavePosition?.y ?? 0.0,\n          middleWavePosition?.rotate ?? 0.2\n        )\n      },\n      bottomWavePosition: {\n        value: new Vector3(\n          bottomWavePosition?.x ?? 2.0,\n          bottomWavePosition?.y ?? -0.7,\n          bottomWavePosition?.rotate ?? 0.4\n        )\n      },\n\n      iMouse: { value: new Vector2(-1000, -1000) },\n      interactive: { value: interactive },\n      bendRadius: { value: bendRadius },\n      bendStrength: { value: bendStrength },\n      bendInfluence: { value: 0 },\n\n      parallax: { value: parallax },\n      parallaxStrength: { value: parallaxStrength },\n      parallaxOffset: { value: new Vector2(0, 0) },\n\n      lineGradient: {\n        value: Array.from({ length: MAX_GRADIENT_STOPS }, () => new Vector3(1, 1, 1))\n      },\n      lineGradientCount: { value: 0 }\n    };\n\n    if (linesGradient && linesGradient.length > 0) {\n      const stops = linesGradient.slice(0, MAX_GRADIENT_STOPS);\n      uniforms.lineGradientCount.value = stops.length;\n\n      stops.forEach((hex, i) => {\n        const color = hexToVec3(hex);\n        uniforms.lineGradient.value[i].set(color.x, color.y, color.z);\n      });\n    }\n\n    const material = new ShaderMaterial({\n      uniforms,\n      vertexShader,\n      fragmentShader\n    });\n\n    const geometry = new PlaneGeometry(2, 2);\n    const mesh = new Mesh(geometry, material);\n    scene.add(mesh);\n\n    const clock = new Clock();\n\n    const setSize = () => {\n      const el = containerRef.current;\n      if (!el) {\n        return;\n      }\n      const width = el.clientWidth || 1;\n      const height = el.clientHeight || 1;\n\n      renderer.setSize(width, height, false);\n\n      const canvasWidth = renderer.domElement.width;\n      const canvasHeight = renderer.domElement.height;\n      uniforms.iResolution.value.set(canvasWidth, canvasHeight, 1);\n    };\n\n    setSize();\n\n    const ro = typeof ResizeObserver !== 'undefined' ? new ResizeObserver(setSize) : null;\n\n    if (ro && containerRef.current) {\n      ro.observe(containerRef.current);\n    }\n\n    const handlePointerMove = event => {\n      const rect = renderer.domElement.getBoundingClientRect();\n      const x = event.clientX - rect.left;\n      const y = event.clientY - rect.top;\n      const dpr = renderer.getPixelRatio();\n\n      targetMouseRef.current.set(x * dpr, (rect.height - y) * dpr);\n      targetInfluenceRef.current = 1.0;\n\n      if (parallax) {\n        const centerX = rect.width / 2;\n        const centerY = rect.height / 2;\n        const offsetX = (x - centerX) / rect.width;\n        const offsetY = -(y - centerY) / rect.height;\n        targetParallaxRef.current.set(offsetX * parallaxStrength, offsetY * parallaxStrength);\n      }\n    };\n\n    const handlePointerLeave = () => {\n      targetInfluenceRef.current = 0.0;\n    };\n\n    if (interactive) {\n      renderer.domElement.addEventListener('pointermove', handlePointerMove);\n      renderer.domElement.addEventListener('pointerleave', handlePointerLeave);\n    }\n\n    let raf = 0;\n    const renderLoop = () => {\n      uniforms.iTime.value = clock.getElapsedTime();\n\n      if (interactive) {\n        currentMouseRef.current.lerp(targetMouseRef.current, mouseDamping);\n        uniforms.iMouse.value.copy(currentMouseRef.current);\n\n        currentInfluenceRef.current += (targetInfluenceRef.current - currentInfluenceRef.current) * mouseDamping;\n        uniforms.bendInfluence.value = currentInfluenceRef.current;\n      }\n\n      if (parallax) {\n        currentParallaxRef.current.lerp(targetParallaxRef.current, mouseDamping);\n        uniforms.parallaxOffset.value.copy(currentParallaxRef.current);\n      }\n\n      renderer.render(scene, camera);\n      raf = requestAnimationFrame(renderLoop);\n    };\n    renderLoop();\n\n    const container = containerRef.current;\n    return () => {\n      cancelAnimationFrame(raf);\n      if (ro && container) {\n        ro.disconnect();\n      }\n\n      if (interactive) {\n        renderer.domElement.removeEventListener('pointermove', handlePointerMove);\n        renderer.domElement.removeEventListener('pointerleave', handlePointerLeave);\n      }\n\n      geometry.dispose();\n      material.dispose();\n      renderer.dispose();\n      if (renderer.domElement.parentElement) {\n        renderer.domElement.parentElement.removeChild(renderer.domElement);\n      }\n    };\n  }, [\n    linesGradient,\n    enabledWaves,\n    lineCount,\n    lineDistance,\n    topWavePosition,\n    middleWavePosition,\n    bottomWavePosition,\n    animationSpeed,\n    interactive,\n    bendRadius,\n    bendStrength,\n    mouseDamping,\n    parallax,\n    parallaxStrength\n  ]);\n\n  return (\n    <div\n      ref={containerRef}\n      className=\"floating-lines-container\"\n      style={{\n        mixBlendMode: mixBlendMode\n      }}\n    />\n  );\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}