{"ast":null,"code":"/**\n * WebAuthn Utility Functions for Biometric Authentication\n * Handles fingerprint/Face ID enrollment and authentication\n *//* eslint-disable no-undef */const BACKEND_URL=process.env.REACT_APP_BACKEND_URL||'http://localhost:8001';// Check if we're on a devtunnel (development domain)\nconst isDevTunnel=()=>{return window.location.hostname.includes('devtunnels.ms')||window.location.hostname.includes('localhost')||window.location.hostname==='127.0.0.1';};// WebAuthn doesn't work reliably on devtunnel domains on mobile\n// It will work fine in production on real domains\nconst WEBAUTHN_AVAILABLE=!isDevTunnel();/**\n * Check if WebAuthn is supported in the current browser\n */export const isWebAuthnSupported=()=>{if(!WEBAUTHN_AVAILABLE){console.warn('‚ÑπÔ∏è WebAuthn not available on development domain. Works in production.');return false;}return typeof window!=='undefined'&&window.PublicKeyCredential!==undefined&&navigator.credentials!==undefined;};/**\n * Check if platform authenticator (fingerprint/Face ID) is available\n */export const isPlatformAuthenticatorAvailable=async()=>{if(!isWebAuthnSupported())return false;try{const available=await window.PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable();return available;}catch(error){console.error('Error checking platform authenticator:',error);return false;}};/**\n * Convert base64url string to ArrayBuffer\n */const base64urlToBuffer=base64url=>{const base64=base64url.replace(/-/g,'+').replace(/_/g,'/');const padLen=(4-base64.length%4)%4;const padded=base64+'='.repeat(padLen);const binary=atob(padded);const bytes=new Uint8Array(binary.length);for(let i=0;i<binary.length;i++){bytes[i]=binary.charCodeAt(i);}return bytes.buffer;};/**\n * Convert ArrayBuffer to base64url string\n */const bufferToBase64url=buffer=>{const bytes=new Uint8Array(buffer);let binary='';for(let i=0;i<bytes.byteLength;i++){binary+=String.fromCharCode(bytes[i]);}return btoa(binary).replace(/\\+/g,'-').replace(/\\//g,'_').replace(/=/g,'');};/**\n * Register a new biometric credential\n * @param {string} deviceName - Optional name for the device\n * @returns {Promise<Object>} Registration result\n */export const registerBiometric=async function(){let deviceName=arguments.length>0&&arguments[0]!==undefined?arguments[0]:null;try{// Check if WebAuthn is supported\nif(!isWebAuthnSupported()){throw new Error('WebAuthn is not supported in this browser');}// Check for platform authenticator\nconst available=await isPlatformAuthenticatorAvailable();if(!available){throw new Error('No biometric authenticator available on this device');}// Get authentication token\nconst token=localStorage.getItem('fdt_token');if(!token){throw new Error('User not authenticated');}// Request challenge from server\nconst challengeResponse=await fetch(\"\".concat(BACKEND_URL,\"/api/auth/register-challenge\"),{method:'POST',headers:{'Authorization':\"Bearer \".concat(token),'Content-Type':'application/json'}});if(!challengeResponse.ok){throw new Error('Failed to get registration challenge');}const{challenge,user_id}=await challengeResponse.json();console.log('üîê WebAuthn Registration Starting:',{hostname:window.location.hostname,challenge:challenge.substring(0,20)+'...'});// Create credential\nconst publicKeyCredentialCreationOptions={challenge:base64urlToBuffer(challenge),rp:{name:'FDT - Fraud Detection',id:window.location.hostname},user:{id:new TextEncoder().encode(user_id),name:user_id,displayName:user_id},pubKeyCredParams:[{alg:-7,type:'public-key'},// ES256\n{alg:-257,type:'public-key'}// RS256\n],authenticatorSelection:{authenticatorAttachment:'platform',requireResidentKey:false,userVerification:'required'},timeout:60000,attestation:'none'};console.log('üì± Calling navigator.credentials.create()...');let credential;try{// Create a timeout promise\nconst timeoutPromise=new Promise((_,reject)=>setTimeout(()=>{console.error('‚è±Ô∏è WebAuthn timeout after 5 seconds');reject(new Error('WebAuthn request timed out - your device may not support this operation'));},5000));// Race between credential creation and timeout\ncredential=await Promise.race([navigator.credentials.create({publicKey:publicKeyCredentialCreationOptions}),timeoutPromise]);}catch(e){console.error('‚ùå navigator.credentials.create() failed:',e);throw e;}console.log('‚úÖ Credential created successfully');if(!credential){throw new Error('Credential creation failed');}console.log('üîê Extracting credential data...');try{// Extract credential data\nconst credentialId=bufferToBase64url(credential.rawId);console.log('‚úÖ Credential ID:',credentialId.substring(0,20)+'...');let publicKey;try{publicKey=bufferToBase64url(credential.response.getPublicKey());console.log('‚úÖ Public key extracted:',publicKey.substring(0,20)+'...');}catch(pkError){console.warn('‚ö†Ô∏è getPublicKey() not available, using attestationObject');// Fallback: encode the entire attestation object\nconst attestationObject=credential.response.attestationObject;publicKey=bufferToBase64url(new Uint8Array(attestationObject));}const aaguid=credential.response.getAuthenticatorData?bufferToBase64url(credential.response.getAuthenticatorData().slice(37,53)):null;console.log('‚úÖ AAGUID:',aaguid);// Get transports if available\nconst transports=credential.response.getTransports?credential.response.getTransports():[];console.log('‚úÖ Transports:',transports);// Register credential with server\nconsole.log('üì§ Sending credential to server...');const registerResponse=await fetch(\"\".concat(BACKEND_URL,\"/api/auth/register-credential\"),{method:'POST',headers:{'Authorization':\"Bearer \".concat(token),'Content-Type':'application/json'},body:JSON.stringify({credential_id:credentialId,public_key:publicKey,device_name:deviceName,aaguid:aaguid,transports:transports})});console.log('üì° Server response status:',registerResponse.status);if(!registerResponse.ok){const error=await registerResponse.json();console.error('‚ùå Server error:',error);throw new Error(error.detail||'Failed to register credential');}const result=await registerResponse.json();console.log('‚úÖ Credential registered successfully:',result);}catch(extractError){console.error('‚ùå Error extracting credential:',extractError);throw extractError;}storedCredentials.push({id:credentialId,name:deviceName||result.credential.credential_name,created:new Date().toISOString()});localStorage.setItem('fdt_credentials',JSON.stringify(storedCredentials));return result;}catch(error){console.error('‚ùå Biometric registration error:',error);console.error('Error details:',{name:error.name,message:error.message,code:error.code});throw error;}};/**\n * Authenticate using biometric credential\n * @param {string} phone - User's phone number\n * @returns {Promise<Object>} Authentication result with token\n */export const authenticateWithBiometric=async phone=>{try{// Check if WebAuthn is supported\nif(!isWebAuthnSupported()){throw new Error('WebAuthn is not supported in this browser');}// Request challenge from server\nconst challengeResponse=await fetch(\"\".concat(BACKEND_URL,\"/api/auth/login-challenge\"),{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({phone})});if(!challengeResponse.ok){const error=await challengeResponse.json();throw new Error(error.detail||'Failed to get login challenge');}const{challenge,allowCredentials}=await challengeResponse.json();// Prepare credential request\nconst publicKeyCredentialRequestOptions={challenge:base64urlToBuffer(challenge),allowCredentials:allowCredentials.map(cred=>({id:base64urlToBuffer(cred.id),type:'public-key',transports:['internal','hybrid']})),userVerification:'required',timeout:60000};// Get credential\nconst assertion=await navigator.credentials.get({publicKey:publicKeyCredentialRequestOptions});if(!assertion){throw new Error('Authentication failed');}// Extract assertion data\nconst credentialId=bufferToBase64url(assertion.rawId);const authenticatorData=bufferToBase64url(assertion.response.authenticatorData);const clientDataJSON=bufferToBase64url(assertion.response.clientDataJSON);const signature=bufferToBase64url(assertion.response.signature);const userHandle=assertion.response.userHandle?bufferToBase64url(assertion.response.userHandle):null;// Send to server for verification\nconst authResponse=await fetch(\"\".concat(BACKEND_URL,\"/api/auth/authenticate-credential\"),{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({credential_id:credentialId,authenticator_data:authenticatorData,client_data_json:clientDataJSON,signature:signature,user_handle:userHandle})});if(!authResponse.ok){const error=await authResponse.json();throw new Error(error.detail||'Authentication failed');}const result=await authResponse.json();// Store token and user data\nlocalStorage.setItem('fdt_token',result.token);localStorage.setItem('fdt_user',JSON.stringify(result.user));return result;}catch(error){console.error('Biometric authentication error:',error);throw error;}};/**\n * Check if user has stored credentials\n * @returns {boolean}\n */export const hasStoredCredentials=()=>{const credentials=localStorage.getItem('fdt_credentials');return credentials&&JSON.parse(credentials).length>0;};/**\n * Get list of registered credentials from server\n * @returns {Promise<Array>}\n */export const getRegisteredCredentials=async()=>{try{const token=localStorage.getItem('fdt_token');if(!token){throw new Error('User not authenticated');}console.log('üîë Fetching registered credentials...');const response=await fetch(\"\".concat(BACKEND_URL,\"/api/auth/credentials\"),{method:'GET',headers:{'Authorization':\"Bearer \".concat(token),'Content-Type':'application/json'}});console.log('üì° Response status:',response.status);if(!response.ok){throw new Error('Failed to fetch credentials');}const data=await response.json();console.log('üìã Credentials data:',data);const credentials=data.credentials||[];console.log('‚úÖ Loaded',credentials.length,'credentials');return credentials;}catch(error){console.error('‚ùå Error fetching credentials:',error);throw error;}};/**\n * Revoke a credential\n * @param {string} credentialId\n * @returns {Promise<Object>}\n */export const revokeCredential=async credentialId=>{try{const token=localStorage.getItem('fdt_token');if(!token){throw new Error('User not authenticated');}const response=await fetch(\"\".concat(BACKEND_URL,\"/api/auth/credentials/\").concat(credentialId),{method:'DELETE',headers:{'Authorization':\"Bearer \".concat(token),'Content-Type':'application/json'}});if(!response.ok){const error=await response.json();throw new Error(error.detail||'Failed to revoke credential');}const result=await response.json();// Remove from local storage\nconst storedCredentials=JSON.parse(localStorage.getItem('fdt_credentials')||'[]');const updated=storedCredentials.filter(c=>c.id!==credentialId);localStorage.setItem('fdt_credentials',JSON.stringify(updated));return result;}catch(error){console.error('Error revoking credential:',error);throw error;}};","map":{"version":3,"names":["BACKEND_URL","process","env","REACT_APP_BACKEND_URL","isDevTunnel","window","location","hostname","includes","WEBAUTHN_AVAILABLE","isWebAuthnSupported","console","warn","PublicKeyCredential","undefined","navigator","credentials","isPlatformAuthenticatorAvailable","available","isUserVerifyingPlatformAuthenticatorAvailable","error","base64urlToBuffer","base64url","base64","replace","padLen","length","padded","repeat","binary","atob","bytes","Uint8Array","i","charCodeAt","buffer","bufferToBase64url","byteLength","String","fromCharCode","btoa","registerBiometric","deviceName","arguments","Error","token","localStorage","getItem","challengeResponse","fetch","concat","method","headers","ok","challenge","user_id","json","log","substring","publicKeyCredentialCreationOptions","rp","name","id","user","TextEncoder","encode","displayName","pubKeyCredParams","alg","type","authenticatorSelection","authenticatorAttachment","requireResidentKey","userVerification","timeout","attestation","credential","timeoutPromise","Promise","_","reject","setTimeout","race","create","publicKey","e","credentialId","rawId","response","getPublicKey","pkError","attestationObject","aaguid","getAuthenticatorData","slice","transports","getTransports","registerResponse","body","JSON","stringify","credential_id","public_key","device_name","status","detail","result","extractError","storedCredentials","push","credential_name","created","Date","toISOString","setItem","message","code","authenticateWithBiometric","phone","allowCredentials","publicKeyCredentialRequestOptions","map","cred","assertion","get","authenticatorData","clientDataJSON","signature","userHandle","authResponse","authenticator_data","client_data_json","user_handle","hasStoredCredentials","parse","getRegisteredCredentials","data","revokeCredential","updated","filter","c"],"sources":["/home/aakash/Projects/Fraud-Detection-in-UPI---FDT2/frontend/src/utils/webauthn.js"],"sourcesContent":["/**\n * WebAuthn Utility Functions for Biometric Authentication\n * Handles fingerprint/Face ID enrollment and authentication\n */\n\n/* eslint-disable no-undef */\nconst BACKEND_URL = process.env.REACT_APP_BACKEND_URL || 'http://localhost:8001';\n\n// Check if we're on a devtunnel (development domain)\nconst isDevTunnel = () => {\n  return window.location.hostname.includes('devtunnels.ms') || \n         window.location.hostname.includes('localhost') ||\n         window.location.hostname === '127.0.0.1';\n};\n\n// WebAuthn doesn't work reliably on devtunnel domains on mobile\n// It will work fine in production on real domains\nconst WEBAUTHN_AVAILABLE = !isDevTunnel();\n\n/**\n * Check if WebAuthn is supported in the current browser\n */\nexport const isWebAuthnSupported = () => {\n  if (!WEBAUTHN_AVAILABLE) {\n    console.warn('‚ÑπÔ∏è WebAuthn not available on development domain. Works in production.');\n    return false;\n  }\n  return typeof window !== 'undefined' && \n         window.PublicKeyCredential !== undefined && \n         navigator.credentials !== undefined;\n};\n\n/**\n * Check if platform authenticator (fingerprint/Face ID) is available\n */\nexport const isPlatformAuthenticatorAvailable = async () => {\n  if (!isWebAuthnSupported()) return false;\n  \n  try {\n    const available = await window.PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable();\n    return available;\n  } catch (error) {\n    console.error('Error checking platform authenticator:', error);\n    return false;\n  }\n};\n\n/**\n * Convert base64url string to ArrayBuffer\n */\nconst base64urlToBuffer = (base64url) => {\n  const base64 = base64url.replace(/-/g, '+').replace(/_/g, '/');\n  const padLen = (4 - (base64.length % 4)) % 4;\n  const padded = base64 + '='.repeat(padLen);\n  const binary = atob(padded);\n  const bytes = new Uint8Array(binary.length);\n  for (let i = 0; i < binary.length; i++) {\n    bytes[i] = binary.charCodeAt(i);\n  }\n  return bytes.buffer;\n};\n\n/**\n * Convert ArrayBuffer to base64url string\n */\nconst bufferToBase64url = (buffer) => {\n  const bytes = new Uint8Array(buffer);\n  let binary = '';\n  for (let i = 0; i < bytes.byteLength; i++) {\n    binary += String.fromCharCode(bytes[i]);\n  }\n  return btoa(binary)\n    .replace(/\\+/g, '-')\n    .replace(/\\//g, '_')\n    .replace(/=/g, '');\n};\n\n/**\n * Register a new biometric credential\n * @param {string} deviceName - Optional name for the device\n * @returns {Promise<Object>} Registration result\n */\nexport const registerBiometric = async (deviceName = null) => {\n  try {\n    // Check if WebAuthn is supported\n    if (!isWebAuthnSupported()) {\n      throw new Error('WebAuthn is not supported in this browser');\n    }\n\n    // Check for platform authenticator\n    const available = await isPlatformAuthenticatorAvailable();\n    if (!available) {\n      throw new Error('No biometric authenticator available on this device');\n    }\n\n    // Get authentication token\n    const token = localStorage.getItem('fdt_token');\n    if (!token) {\n      throw new Error('User not authenticated');\n    }\n\n    // Request challenge from server\n    const challengeResponse = await fetch(`${BACKEND_URL}/api/auth/register-challenge`, {\n      method: 'POST',\n      headers: {\n        'Authorization': `Bearer ${token}`,\n        'Content-Type': 'application/json'\n      }\n    });\n\n    if (!challengeResponse.ok) {\n      throw new Error('Failed to get registration challenge');\n    }\n\n    const { challenge, user_id } = await challengeResponse.json();\n    \n    console.log('üîê WebAuthn Registration Starting:', {\n      hostname: window.location.hostname,\n      challenge: challenge.substring(0, 20) + '...'\n    });\n\n    // Create credential\n    const publicKeyCredentialCreationOptions = {\n      challenge: base64urlToBuffer(challenge),\n      rp: {\n        name: 'FDT - Fraud Detection',\n        id: window.location.hostname\n      },\n      user: {\n        id: new TextEncoder().encode(user_id),\n        name: user_id,\n        displayName: user_id\n      },\n      pubKeyCredParams: [\n        { alg: -7, type: 'public-key' },  // ES256\n        { alg: -257, type: 'public-key' } // RS256\n      ],\n      authenticatorSelection: {\n        authenticatorAttachment: 'platform',\n        requireResidentKey: false,\n        userVerification: 'required'\n      },\n      timeout: 60000,\n      attestation: 'none'\n    };\n\n    console.log('üì± Calling navigator.credentials.create()...');\n    \n    let credential;\n    try {\n      // Create a timeout promise\n      const timeoutPromise = new Promise((_, reject) => \n        setTimeout(() => {\n          console.error('‚è±Ô∏è WebAuthn timeout after 5 seconds');\n          reject(new Error('WebAuthn request timed out - your device may not support this operation'));\n        }, 5000)\n      );\n      \n      // Race between credential creation and timeout\n      credential = await Promise.race([\n        navigator.credentials.create({\n          publicKey: publicKeyCredentialCreationOptions\n        }),\n        timeoutPromise\n      ]);\n    } catch (e) {\n      console.error('‚ùå navigator.credentials.create() failed:', e);\n      throw e;\n    }\n    \n    console.log('‚úÖ Credential created successfully');\n\n    if (!credential) {\n      throw new Error('Credential creation failed');\n    }\n\n    console.log('üîê Extracting credential data...');\n    \n    try {\n      // Extract credential data\n      const credentialId = bufferToBase64url(credential.rawId);\n      console.log('‚úÖ Credential ID:', credentialId.substring(0, 20) + '...');\n      \n      let publicKey;\n      try {\n        publicKey = bufferToBase64url(credential.response.getPublicKey());\n        console.log('‚úÖ Public key extracted:', publicKey.substring(0, 20) + '...');\n      } catch (pkError) {\n        console.warn('‚ö†Ô∏è getPublicKey() not available, using attestationObject');\n        // Fallback: encode the entire attestation object\n        const attestationObject = credential.response.attestationObject;\n        publicKey = bufferToBase64url(new Uint8Array(attestationObject));\n      }\n      \n      const aaguid = credential.response.getAuthenticatorData ? \n        bufferToBase64url(credential.response.getAuthenticatorData().slice(37, 53)) : null;\n      console.log('‚úÖ AAGUID:', aaguid);\n\n      // Get transports if available\n      const transports = credential.response.getTransports ? \n        credential.response.getTransports() : [];\n      console.log('‚úÖ Transports:', transports);\n\n      // Register credential with server\n      console.log('üì§ Sending credential to server...');\n      const registerResponse = await fetch(`${BACKEND_URL}/api/auth/register-credential`, {\n        method: 'POST',\n        headers: {\n          'Authorization': `Bearer ${token}`,\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          credential_id: credentialId,\n          public_key: publicKey,\n          device_name: deviceName,\n          aaguid: aaguid,\n          transports: transports\n        })\n      });\n\n      console.log('üì° Server response status:', registerResponse.status);\n\n      if (!registerResponse.ok) {\n        const error = await registerResponse.json();\n        console.error('‚ùå Server error:', error);\n        throw new Error(error.detail || 'Failed to register credential');\n      }\n      \n      const result = await registerResponse.json();\n      console.log('‚úÖ Credential registered successfully:', result);\n    } catch (extractError) {\n      console.error('‚ùå Error extracting credential:', extractError);\n      throw extractError;\n    }\n    storedCredentials.push({\n      id: credentialId,\n      name: deviceName || result.credential.credential_name,\n      created: new Date().toISOString()\n    });\n    localStorage.setItem('fdt_credentials', JSON.stringify(storedCredentials));\n\n    return result;\n  } catch (error) {\n    console.error('‚ùå Biometric registration error:', error);\n    console.error('Error details:', {\n      name: error.name,\n      message: error.message,\n      code: error.code\n    });\n    throw error;\n  }\n};\n\n/**\n * Authenticate using biometric credential\n * @param {string} phone - User's phone number\n * @returns {Promise<Object>} Authentication result with token\n */\nexport const authenticateWithBiometric = async (phone) => {\n  try {\n    // Check if WebAuthn is supported\n    if (!isWebAuthnSupported()) {\n      throw new Error('WebAuthn is not supported in this browser');\n    }\n\n    // Request challenge from server\n    const challengeResponse = await fetch(`${BACKEND_URL}/api/auth/login-challenge`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({ phone })\n    });\n\n    if (!challengeResponse.ok) {\n      const error = await challengeResponse.json();\n      throw new Error(error.detail || 'Failed to get login challenge');\n    }\n\n    const { challenge, allowCredentials } = await challengeResponse.json();\n\n    // Prepare credential request\n    const publicKeyCredentialRequestOptions = {\n      challenge: base64urlToBuffer(challenge),\n      allowCredentials: allowCredentials.map(cred => ({\n        id: base64urlToBuffer(cred.id),\n        type: 'public-key',\n        transports: ['internal', 'hybrid']\n      })),\n      userVerification: 'required',\n      timeout: 60000\n    };\n\n    // Get credential\n    const assertion = await navigator.credentials.get({\n      publicKey: publicKeyCredentialRequestOptions\n    });\n\n    if (!assertion) {\n      throw new Error('Authentication failed');\n    }\n\n    // Extract assertion data\n    const credentialId = bufferToBase64url(assertion.rawId);\n    const authenticatorData = bufferToBase64url(assertion.response.authenticatorData);\n    const clientDataJSON = bufferToBase64url(assertion.response.clientDataJSON);\n    const signature = bufferToBase64url(assertion.response.signature);\n    const userHandle = assertion.response.userHandle ? \n      bufferToBase64url(assertion.response.userHandle) : null;\n\n    // Send to server for verification\n    const authResponse = await fetch(`${BACKEND_URL}/api/auth/authenticate-credential`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({\n        credential_id: credentialId,\n        authenticator_data: authenticatorData,\n        client_data_json: clientDataJSON,\n        signature: signature,\n        user_handle: userHandle\n      })\n    });\n\n    if (!authResponse.ok) {\n      const error = await authResponse.json();\n      throw new Error(error.detail || 'Authentication failed');\n    }\n\n    const result = await authResponse.json();\n\n    // Store token and user data\n    localStorage.setItem('fdt_token', result.token);\n    localStorage.setItem('fdt_user', JSON.stringify(result.user));\n\n    return result;\n  } catch (error) {\n    console.error('Biometric authentication error:', error);\n    throw error;\n  }\n};\n\n/**\n * Check if user has stored credentials\n * @returns {boolean}\n */\nexport const hasStoredCredentials = () => {\n  const credentials = localStorage.getItem('fdt_credentials');\n  return credentials && JSON.parse(credentials).length > 0;\n};\n\n/**\n * Get list of registered credentials from server\n * @returns {Promise<Array>}\n */\nexport const getRegisteredCredentials = async () => {\n  try {\n    const token = localStorage.getItem('fdt_token');\n    if (!token) {\n      throw new Error('User not authenticated');\n    }\n\n    console.log('üîë Fetching registered credentials...');\n    const response = await fetch(`${BACKEND_URL}/api/auth/credentials`, {\n      method: 'GET',\n      headers: {\n        'Authorization': `Bearer ${token}`,\n        'Content-Type': 'application/json'\n      }\n    });\n\n    console.log('üì° Response status:', response.status);\n\n    if (!response.ok) {\n      throw new Error('Failed to fetch credentials');\n    }\n\n    const data = await response.json();\n    console.log('üìã Credentials data:', data);\n    \n    const credentials = data.credentials || [];\n    console.log('‚úÖ Loaded', credentials.length, 'credentials');\n    \n    return credentials;\n  } catch (error) {\n    console.error('‚ùå Error fetching credentials:', error);\n    throw error;\n  }\n};\n\n/**\n * Revoke a credential\n * @param {string} credentialId\n * @returns {Promise<Object>}\n */\nexport const revokeCredential = async (credentialId) => {\n  try {\n    const token = localStorage.getItem('fdt_token');\n    if (!token) {\n      throw new Error('User not authenticated');\n    }\n\n    const response = await fetch(`${BACKEND_URL}/api/auth/credentials/${credentialId}`, {\n      method: 'DELETE',\n      headers: {\n        'Authorization': `Bearer ${token}`,\n        'Content-Type': 'application/json'\n      }\n    });\n\n    if (!response.ok) {\n      const error = await response.json();\n      throw new Error(error.detail || 'Failed to revoke credential');\n    }\n\n    const result = await response.json();\n\n    // Remove from local storage\n    const storedCredentials = JSON.parse(localStorage.getItem('fdt_credentials') || '[]');\n    const updated = storedCredentials.filter(c => c.id !== credentialId);\n    localStorage.setItem('fdt_credentials', JSON.stringify(updated));\n\n    return result;\n  } catch (error) {\n    console.error('Error revoking credential:', error);\n    throw error;\n  }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}