{"ast":null,"code":"var _jsxFileName = \"/home/aakash/Projects/Fraud-Detection-in-UPI---FDT2/frontend/src/components/FloatingLines.js\",\n  _s = $RefreshSig$();\nimport { useEffect, useRef } from 'react';\nimport { Scene, OrthographicCamera, WebGLRenderer, PlaneGeometry, Mesh, ShaderMaterial, Vector3, Vector2, Clock } from 'three';\nimport './FloatingLines.css';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst vertexShader = `\nprecision highp float;\n\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n`;\nconst fragmentShader = `\nprecision highp float;\n\nuniform float iTime;\nuniform vec3  iResolution;\nuniform float animationSpeed;\n\nuniform bool enableTop;\nuniform bool enableMiddle;\nuniform bool enableBottom;\n\nuniform int topLineCount;\nuniform int middleLineCount;\nuniform int bottomLineCount;\n\nuniform float topLineDistance;\nuniform float middleLineDistance;\nuniform float bottomLineDistance;\n\nuniform vec3 topWavePosition;\nuniform vec3 middleWavePosition;\nuniform vec3 bottomWavePosition;\n\nuniform vec2 iMouse;\nuniform bool interactive;\nuniform float bendRadius;\nuniform float bendStrength;\nuniform float bendInfluence;\n\nuniform bool parallax;\nuniform float parallaxStrength;\nuniform vec2 parallaxOffset;\n\nuniform vec3 lineGradient[8];\nuniform int lineGradientCount;\n\nconst vec3 BLACK = vec3(0.0);\nconst vec3 PINK  = vec3(233.0, 71.0, 245.0) / 255.0;\nconst vec3 BLUE  = vec3(47.0,  75.0, 162.0) / 255.0;\n\nmat2 rotate(float r) {\n  return mat2(cos(r), sin(r), -sin(r), cos(r));\n}\n\nvec3 background_color(vec2 uv) {\n  vec3 col = vec3(0.0);\n\n  float y = sin(uv.x - 0.2) * 0.3 - 0.1;\n  float m = uv.y - y;\n\n  col += mix(BLUE, BLACK, smoothstep(0.0, 1.0, abs(m)));\n  col += mix(PINK, BLACK, smoothstep(0.0, 1.0, abs(m - 0.8)));\n  return col * 0.5;\n}\n\nvec3 getLineColor(float t, vec3 baseColor) {\n  if (lineGradientCount <= 0) {\n    return baseColor;\n  }\n\n  vec3 gradientColor;\n  \n  if (lineGradientCount == 1) {\n    gradientColor = lineGradient[0];\n  } else {\n    float clampedT = clamp(t, 0.0, 0.9999);\n    float scaled = clampedT * float(lineGradientCount - 1);\n    int idx = int(floor(scaled));\n    float f = fract(scaled);\n    int idx2 = min(idx + 1, lineGradientCount - 1);\n\n    vec3 c1 = lineGradient[idx];\n    vec3 c2 = lineGradient[idx2];\n    \n    gradientColor = mix(c1, c2, f);\n  }\n  \n  return gradientColor * 0.5;\n}\n\n  float wave(vec2 uv, float offset, vec2 screenUv, vec2 mouseUv, bool shouldBend) {\n  float time = iTime * animationSpeed;\n\n  float x_offset   = offset;\n  float x_movement = time * 0.1;\n  float amp        = sin(offset + time * 0.2) * 0.3;\n  float y          = sin(uv.x + x_offset + x_movement) * amp;\n\n  if (shouldBend) {\n    vec2 d = screenUv - mouseUv;\n    float influence = exp(-dot(d, d) * bendRadius); // radial falloff around cursor\n    float bendOffset = (mouseUv.y - screenUv.y) * influence * bendStrength * bendInfluence;\n    y += bendOffset;\n  }\n\n  float m = uv.y - y;\n  return 0.0175 / max(abs(m) + 0.01, 1e-3) + 0.01;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 baseUv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n  baseUv.y *= -1.0;\n  \n  if (parallax) {\n    baseUv += parallaxOffset;\n  }\n\n  vec3 col = vec3(0.0);\n\n  vec3 b = lineGradientCount > 0 ? vec3(0.0) : background_color(baseUv);\n\n  vec2 mouseUv = vec2(0.0);\n  if (interactive) {\n    mouseUv = (2.0 * iMouse - iResolution.xy) / iResolution.y;\n    mouseUv.y *= -1.0;\n  }\n  \n  if (enableBottom) {\n    for (int i = 0; i < bottomLineCount; ++i) {\n      float fi = float(i);\n      float t = fi / max(float(bottomLineCount - 1), 1.0);\n      vec3 lineCol = getLineColor(t, b);\n      \n      float angle = bottomWavePosition.z * log(length(baseUv) + 1.0);\n      vec2 ruv = baseUv * rotate(angle);\n      col += lineCol * wave(\n        ruv + vec2(bottomLineDistance * fi + bottomWavePosition.x, bottomWavePosition.y),\n        1.5 + 0.2 * fi,\n        baseUv,\n        mouseUv,\n        interactive\n      ) * 0.2;\n    }\n  }\n\n  if (enableMiddle) {\n    for (int i = 0; i < middleLineCount; ++i) {\n      float fi = float(i);\n      float t = fi / max(float(middleLineCount - 1), 1.0);\n      vec3 lineCol = getLineColor(t, b);\n      \n      float angle = middleWavePosition.z * log(length(baseUv) + 1.0);\n      vec2 ruv = baseUv * rotate(angle);\n      col += lineCol * wave(\n        ruv + vec2(middleLineDistance * fi + middleWavePosition.x, middleWavePosition.y),\n        2.0 + 0.15 * fi,\n        baseUv,\n        mouseUv,\n        interactive\n      );\n    }\n  }\n\n  if (enableTop) {\n    for (int i = 0; i < topLineCount; ++i) {\n      float fi = float(i);\n      float t = fi / max(float(topLineCount - 1), 1.0);\n      vec3 lineCol = getLineColor(t, b);\n      \n      float angle = topWavePosition.z * log(length(baseUv) + 1.0);\n      vec2 ruv = baseUv * rotate(angle);\n      ruv.x *= -1.0;\n      col += lineCol * wave(\n        ruv + vec2(topLineDistance * fi + topWavePosition.x, topWavePosition.y),\n        1.0 + 0.2 * fi,\n        baseUv,\n        mouseUv,\n        interactive\n      ) * 0.1;\n    }\n  }\n\n  fragColor = vec4(col, 1.0);\n}\n\nvoid main() {\n  vec4 color = vec4(0.0);\n  mainImage(color, gl_FragCoord.xy);\n  gl_FragColor = color;\n}\n`;\nconst MAX_GRADIENT_STOPS = 8;\nfunction hexToVec3(hex) {\n  let value = hex.trim();\n  if (value.startsWith('#')) {\n    value = value.slice(1);\n  }\n  let r = 255;\n  let g = 255;\n  let b = 255;\n  if (value.length === 3) {\n    r = parseInt(value[0] + value[0], 16);\n    g = parseInt(value[1] + value[1], 16);\n    b = parseInt(value[2] + value[2], 16);\n  } else if (value.length === 6) {\n    r = parseInt(value.slice(0, 2), 16);\n    g = parseInt(value.slice(2, 4), 16);\n    b = parseInt(value.slice(4, 6), 16);\n  }\n  return new Vector3(r / 255, g / 255, b / 255);\n}\nexport default function FloatingLines({\n  linesGradient,\n  enabledWaves = ['top', 'middle', 'bottom'],\n  lineCount = [6],\n  lineDistance = [5],\n  topWavePosition,\n  middleWavePosition,\n  bottomWavePosition = {\n    x: 2.0,\n    y: -0.7,\n    rotate: -1\n  },\n  animationSpeed = 1,\n  interactive = true,\n  bendRadius = 5.0,\n  bendStrength = -0.5,\n  mouseDamping = 0.05,\n  parallax = true,\n  parallaxStrength = 0.2,\n  mixBlendMode = 'screen'\n}) {\n  _s();\n  const containerRef = useRef(null);\n  const targetMouseRef = useRef(new Vector2(-1000, -1000));\n  const currentMouseRef = useRef(new Vector2(-1000, -1000));\n  const targetInfluenceRef = useRef(0);\n  const currentInfluenceRef = useRef(0);\n  const targetParallaxRef = useRef(new Vector2(0, 0));\n  const currentParallaxRef = useRef(new Vector2(0, 0));\n  useEffect(() => {\n    var _topWavePosition$x, _topWavePosition$y, _topWavePosition$rota, _middleWavePosition$x, _middleWavePosition$y, _middleWavePosition$r, _bottomWavePosition$x, _bottomWavePosition$y, _bottomWavePosition$r;\n    if (!containerRef.current) return;\n\n    // Helper functions\n    const getLineCount = waveType => {\n      var _lineCount$index;\n      if (typeof lineCount === 'number') return lineCount;\n      if (!enabledWaves.includes(waveType)) return 0;\n      const index = enabledWaves.indexOf(waveType);\n      return (_lineCount$index = lineCount[index]) !== null && _lineCount$index !== void 0 ? _lineCount$index : 6;\n    };\n    const getLineDistance = waveType => {\n      var _lineDistance$index;\n      if (typeof lineDistance === 'number') return lineDistance;\n      if (!enabledWaves.includes(waveType)) return 0.1;\n      const index = enabledWaves.indexOf(waveType);\n      return (_lineDistance$index = lineDistance[index]) !== null && _lineDistance$index !== void 0 ? _lineDistance$index : 0.1;\n    };\n\n    // Calculate line counts and distances inside effect\n    const topLineCount = enabledWaves.includes('top') ? getLineCount('top') : 0;\n    const middleLineCount = enabledWaves.includes('middle') ? getLineCount('middle') : 0;\n    const bottomLineCount = enabledWaves.includes('bottom') ? getLineCount('bottom') : 0;\n    const topLineDistance = enabledWaves.includes('top') ? getLineDistance('top') * 0.01 : 0.01;\n    const middleLineDistance = enabledWaves.includes('middle') ? getLineDistance('middle') * 0.01 : 0.01;\n    const bottomLineDistance = enabledWaves.includes('bottom') ? getLineDistance('bottom') * 0.01 : 0.01;\n    const scene = new Scene();\n    const camera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);\n    camera.position.z = 1;\n    const renderer = new WebGLRenderer({\n      antialias: true,\n      alpha: false\n    });\n    renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));\n    renderer.domElement.style.width = '100%';\n    renderer.domElement.style.height = '100%';\n    containerRef.current.appendChild(renderer.domElement);\n    const uniforms = {\n      iTime: {\n        value: 0\n      },\n      iResolution: {\n        value: new Vector3(1, 1, 1)\n      },\n      animationSpeed: {\n        value: animationSpeed\n      },\n      enableTop: {\n        value: enabledWaves.includes('top')\n      },\n      enableMiddle: {\n        value: enabledWaves.includes('middle')\n      },\n      enableBottom: {\n        value: enabledWaves.includes('bottom')\n      },\n      topLineCount: {\n        value: topLineCount\n      },\n      middleLineCount: {\n        value: middleLineCount\n      },\n      bottomLineCount: {\n        value: bottomLineCount\n      },\n      topLineDistance: {\n        value: topLineDistance\n      },\n      middleLineDistance: {\n        value: middleLineDistance\n      },\n      bottomLineDistance: {\n        value: bottomLineDistance\n      },\n      topWavePosition: {\n        value: new Vector3((_topWavePosition$x = topWavePosition === null || topWavePosition === void 0 ? void 0 : topWavePosition.x) !== null && _topWavePosition$x !== void 0 ? _topWavePosition$x : 10.0, (_topWavePosition$y = topWavePosition === null || topWavePosition === void 0 ? void 0 : topWavePosition.y) !== null && _topWavePosition$y !== void 0 ? _topWavePosition$y : 0.5, (_topWavePosition$rota = topWavePosition === null || topWavePosition === void 0 ? void 0 : topWavePosition.rotate) !== null && _topWavePosition$rota !== void 0 ? _topWavePosition$rota : -0.4)\n      },\n      middleWavePosition: {\n        value: new Vector3((_middleWavePosition$x = middleWavePosition === null || middleWavePosition === void 0 ? void 0 : middleWavePosition.x) !== null && _middleWavePosition$x !== void 0 ? _middleWavePosition$x : 5.0, (_middleWavePosition$y = middleWavePosition === null || middleWavePosition === void 0 ? void 0 : middleWavePosition.y) !== null && _middleWavePosition$y !== void 0 ? _middleWavePosition$y : 0.0, (_middleWavePosition$r = middleWavePosition === null || middleWavePosition === void 0 ? void 0 : middleWavePosition.rotate) !== null && _middleWavePosition$r !== void 0 ? _middleWavePosition$r : 0.2)\n      },\n      bottomWavePosition: {\n        value: new Vector3((_bottomWavePosition$x = bottomWavePosition === null || bottomWavePosition === void 0 ? void 0 : bottomWavePosition.x) !== null && _bottomWavePosition$x !== void 0 ? _bottomWavePosition$x : 2.0, (_bottomWavePosition$y = bottomWavePosition === null || bottomWavePosition === void 0 ? void 0 : bottomWavePosition.y) !== null && _bottomWavePosition$y !== void 0 ? _bottomWavePosition$y : -0.7, (_bottomWavePosition$r = bottomWavePosition === null || bottomWavePosition === void 0 ? void 0 : bottomWavePosition.rotate) !== null && _bottomWavePosition$r !== void 0 ? _bottomWavePosition$r : 0.4)\n      },\n      iMouse: {\n        value: new Vector2(-1000, -1000)\n      },\n      interactive: {\n        value: interactive\n      },\n      bendRadius: {\n        value: bendRadius\n      },\n      bendStrength: {\n        value: bendStrength\n      },\n      bendInfluence: {\n        value: 0\n      },\n      parallax: {\n        value: parallax\n      },\n      parallaxStrength: {\n        value: parallaxStrength\n      },\n      parallaxOffset: {\n        value: new Vector2(0, 0)\n      },\n      lineGradient: {\n        value: Array.from({\n          length: MAX_GRADIENT_STOPS\n        }, () => new Vector3(1, 1, 1))\n      },\n      lineGradientCount: {\n        value: 0\n      }\n    };\n    if (linesGradient && linesGradient.length > 0) {\n      const stops = linesGradient.slice(0, MAX_GRADIENT_STOPS);\n      uniforms.lineGradientCount.value = stops.length;\n      stops.forEach((hex, i) => {\n        const color = hexToVec3(hex);\n        uniforms.lineGradient.value[i].set(color.x, color.y, color.z);\n      });\n    }\n    const material = new ShaderMaterial({\n      uniforms,\n      vertexShader,\n      fragmentShader\n    });\n    const geometry = new PlaneGeometry(2, 2);\n    const mesh = new Mesh(geometry, material);\n    scene.add(mesh);\n    const clock = new Clock();\n    const setSize = () => {\n      const el = containerRef.current;\n      if (!el) {\n        return;\n      }\n      const width = el.clientWidth || 1;\n      const height = el.clientHeight || 1;\n      renderer.setSize(width, height, false);\n      const canvasWidth = renderer.domElement.width;\n      const canvasHeight = renderer.domElement.height;\n      uniforms.iResolution.value.set(canvasWidth, canvasHeight, 1);\n    };\n    setSize();\n    const ro = typeof ResizeObserver !== 'undefined' ? new ResizeObserver(setSize) : null;\n    if (ro && containerRef.current) {\n      ro.observe(containerRef.current);\n    }\n    const handlePointerMove = event => {\n      const rect = renderer.domElement.getBoundingClientRect();\n      const x = event.clientX - rect.left;\n      const y = event.clientY - rect.top;\n      const dpr = renderer.getPixelRatio();\n      targetMouseRef.current.set(x * dpr, (rect.height - y) * dpr);\n      targetInfluenceRef.current = 1.0;\n      if (parallax) {\n        const centerX = rect.width / 2;\n        const centerY = rect.height / 2;\n        const offsetX = (x - centerX) / rect.width;\n        const offsetY = -(y - centerY) / rect.height;\n        targetParallaxRef.current.set(offsetX * parallaxStrength, offsetY * parallaxStrength);\n      }\n    };\n    const handlePointerLeave = () => {\n      targetInfluenceRef.current = 0.0;\n    };\n    if (interactive) {\n      renderer.domElement.addEventListener('pointermove', handlePointerMove);\n      renderer.domElement.addEventListener('pointerleave', handlePointerLeave);\n    }\n    let raf = 0;\n    const renderLoop = () => {\n      uniforms.iTime.value = clock.getElapsedTime();\n      if (interactive) {\n        currentMouseRef.current.lerp(targetMouseRef.current, mouseDamping);\n        uniforms.iMouse.value.copy(currentMouseRef.current);\n        currentInfluenceRef.current += (targetInfluenceRef.current - currentInfluenceRef.current) * mouseDamping;\n        uniforms.bendInfluence.value = currentInfluenceRef.current;\n      }\n      if (parallax) {\n        currentParallaxRef.current.lerp(targetParallaxRef.current, mouseDamping);\n        uniforms.parallaxOffset.value.copy(currentParallaxRef.current);\n      }\n      renderer.render(scene, camera);\n      raf = requestAnimationFrame(renderLoop);\n    };\n    renderLoop();\n    const container = containerRef.current;\n    return () => {\n      cancelAnimationFrame(raf);\n      if (ro && container) {\n        ro.disconnect();\n      }\n      if (interactive) {\n        renderer.domElement.removeEventListener('pointermove', handlePointerMove);\n        renderer.domElement.removeEventListener('pointerleave', handlePointerLeave);\n      }\n      geometry.dispose();\n      material.dispose();\n      renderer.dispose();\n      if (renderer.domElement.parentElement) {\n        renderer.domElement.parentElement.removeChild(renderer.domElement);\n      }\n    };\n  }, [linesGradient, enabledWaves, lineCount, lineDistance, topWavePosition, middleWavePosition, bottomWavePosition, animationSpeed, interactive, bendRadius, bendStrength, mouseDamping, parallax, parallaxStrength]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    ref: containerRef,\n    className: \"floating-lines-container\",\n    style: {\n      mixBlendMode: mixBlendMode\n    }\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 477,\n    columnNumber: 5\n  }, this);\n}\n_s(FloatingLines, \"JeFiEeHCpJ9t4iS96WrDDb1RN5M=\");\n_c = FloatingLines;\nvar _c;\n$RefreshReg$(_c, \"FloatingLines\");","map":{"version":3,"names":["useEffect","useRef","Scene","OrthographicCamera","WebGLRenderer","PlaneGeometry","Mesh","ShaderMaterial","Vector3","Vector2","Clock","jsxDEV","_jsxDEV","vertexShader","fragmentShader","MAX_GRADIENT_STOPS","hexToVec3","hex","value","trim","startsWith","slice","r","g","b","length","parseInt","FloatingLines","linesGradient","enabledWaves","lineCount","lineDistance","topWavePosition","middleWavePosition","bottomWavePosition","x","y","rotate","animationSpeed","interactive","bendRadius","bendStrength","mouseDamping","parallax","parallaxStrength","mixBlendMode","_s","containerRef","targetMouseRef","currentMouseRef","targetInfluenceRef","currentInfluenceRef","targetParallaxRef","currentParallaxRef","_topWavePosition$x","_topWavePosition$y","_topWavePosition$rota","_middleWavePosition$x","_middleWavePosition$y","_middleWavePosition$r","_bottomWavePosition$x","_bottomWavePosition$y","_bottomWavePosition$r","current","getLineCount","waveType","_lineCount$index","includes","index","indexOf","getLineDistance","_lineDistance$index","topLineCount","middleLineCount","bottomLineCount","topLineDistance","middleLineDistance","bottomLineDistance","scene","camera","position","z","renderer","antialias","alpha","setPixelRatio","Math","min","window","devicePixelRatio","domElement","style","width","height","appendChild","uniforms","iTime","iResolution","enableTop","enableMiddle","enableBottom","iMouse","bendInfluence","parallaxOffset","lineGradient","Array","from","lineGradientCount","stops","forEach","i","color","set","material","geometry","mesh","add","clock","setSize","el","clientWidth","clientHeight","canvasWidth","canvasHeight","ro","ResizeObserver","observe","handlePointerMove","event","rect","getBoundingClientRect","clientX","left","clientY","top","dpr","getPixelRatio","centerX","centerY","offsetX","offsetY","handlePointerLeave","addEventListener","raf","renderLoop","getElapsedTime","lerp","copy","render","requestAnimationFrame","container","cancelAnimationFrame","disconnect","removeEventListener","dispose","parentElement","removeChild","ref","className","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/home/aakash/Projects/Fraud-Detection-in-UPI---FDT2/frontend/src/components/FloatingLines.js"],"sourcesContent":["import { useEffect, useRef } from 'react';\nimport {\n  Scene,\n  OrthographicCamera,\n  WebGLRenderer,\n  PlaneGeometry,\n  Mesh,\n  ShaderMaterial,\n  Vector3,\n  Vector2,\n  Clock\n} from 'three';\n\nimport './FloatingLines.css';\n\nconst vertexShader = `\nprecision highp float;\n\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n`;\n\nconst fragmentShader = `\nprecision highp float;\n\nuniform float iTime;\nuniform vec3  iResolution;\nuniform float animationSpeed;\n\nuniform bool enableTop;\nuniform bool enableMiddle;\nuniform bool enableBottom;\n\nuniform int topLineCount;\nuniform int middleLineCount;\nuniform int bottomLineCount;\n\nuniform float topLineDistance;\nuniform float middleLineDistance;\nuniform float bottomLineDistance;\n\nuniform vec3 topWavePosition;\nuniform vec3 middleWavePosition;\nuniform vec3 bottomWavePosition;\n\nuniform vec2 iMouse;\nuniform bool interactive;\nuniform float bendRadius;\nuniform float bendStrength;\nuniform float bendInfluence;\n\nuniform bool parallax;\nuniform float parallaxStrength;\nuniform vec2 parallaxOffset;\n\nuniform vec3 lineGradient[8];\nuniform int lineGradientCount;\n\nconst vec3 BLACK = vec3(0.0);\nconst vec3 PINK  = vec3(233.0, 71.0, 245.0) / 255.0;\nconst vec3 BLUE  = vec3(47.0,  75.0, 162.0) / 255.0;\n\nmat2 rotate(float r) {\n  return mat2(cos(r), sin(r), -sin(r), cos(r));\n}\n\nvec3 background_color(vec2 uv) {\n  vec3 col = vec3(0.0);\n\n  float y = sin(uv.x - 0.2) * 0.3 - 0.1;\n  float m = uv.y - y;\n\n  col += mix(BLUE, BLACK, smoothstep(0.0, 1.0, abs(m)));\n  col += mix(PINK, BLACK, smoothstep(0.0, 1.0, abs(m - 0.8)));\n  return col * 0.5;\n}\n\nvec3 getLineColor(float t, vec3 baseColor) {\n  if (lineGradientCount <= 0) {\n    return baseColor;\n  }\n\n  vec3 gradientColor;\n  \n  if (lineGradientCount == 1) {\n    gradientColor = lineGradient[0];\n  } else {\n    float clampedT = clamp(t, 0.0, 0.9999);\n    float scaled = clampedT * float(lineGradientCount - 1);\n    int idx = int(floor(scaled));\n    float f = fract(scaled);\n    int idx2 = min(idx + 1, lineGradientCount - 1);\n\n    vec3 c1 = lineGradient[idx];\n    vec3 c2 = lineGradient[idx2];\n    \n    gradientColor = mix(c1, c2, f);\n  }\n  \n  return gradientColor * 0.5;\n}\n\n  float wave(vec2 uv, float offset, vec2 screenUv, vec2 mouseUv, bool shouldBend) {\n  float time = iTime * animationSpeed;\n\n  float x_offset   = offset;\n  float x_movement = time * 0.1;\n  float amp        = sin(offset + time * 0.2) * 0.3;\n  float y          = sin(uv.x + x_offset + x_movement) * amp;\n\n  if (shouldBend) {\n    vec2 d = screenUv - mouseUv;\n    float influence = exp(-dot(d, d) * bendRadius); // radial falloff around cursor\n    float bendOffset = (mouseUv.y - screenUv.y) * influence * bendStrength * bendInfluence;\n    y += bendOffset;\n  }\n\n  float m = uv.y - y;\n  return 0.0175 / max(abs(m) + 0.01, 1e-3) + 0.01;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 baseUv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n  baseUv.y *= -1.0;\n  \n  if (parallax) {\n    baseUv += parallaxOffset;\n  }\n\n  vec3 col = vec3(0.0);\n\n  vec3 b = lineGradientCount > 0 ? vec3(0.0) : background_color(baseUv);\n\n  vec2 mouseUv = vec2(0.0);\n  if (interactive) {\n    mouseUv = (2.0 * iMouse - iResolution.xy) / iResolution.y;\n    mouseUv.y *= -1.0;\n  }\n  \n  if (enableBottom) {\n    for (int i = 0; i < bottomLineCount; ++i) {\n      float fi = float(i);\n      float t = fi / max(float(bottomLineCount - 1), 1.0);\n      vec3 lineCol = getLineColor(t, b);\n      \n      float angle = bottomWavePosition.z * log(length(baseUv) + 1.0);\n      vec2 ruv = baseUv * rotate(angle);\n      col += lineCol * wave(\n        ruv + vec2(bottomLineDistance * fi + bottomWavePosition.x, bottomWavePosition.y),\n        1.5 + 0.2 * fi,\n        baseUv,\n        mouseUv,\n        interactive\n      ) * 0.2;\n    }\n  }\n\n  if (enableMiddle) {\n    for (int i = 0; i < middleLineCount; ++i) {\n      float fi = float(i);\n      float t = fi / max(float(middleLineCount - 1), 1.0);\n      vec3 lineCol = getLineColor(t, b);\n      \n      float angle = middleWavePosition.z * log(length(baseUv) + 1.0);\n      vec2 ruv = baseUv * rotate(angle);\n      col += lineCol * wave(\n        ruv + vec2(middleLineDistance * fi + middleWavePosition.x, middleWavePosition.y),\n        2.0 + 0.15 * fi,\n        baseUv,\n        mouseUv,\n        interactive\n      );\n    }\n  }\n\n  if (enableTop) {\n    for (int i = 0; i < topLineCount; ++i) {\n      float fi = float(i);\n      float t = fi / max(float(topLineCount - 1), 1.0);\n      vec3 lineCol = getLineColor(t, b);\n      \n      float angle = topWavePosition.z * log(length(baseUv) + 1.0);\n      vec2 ruv = baseUv * rotate(angle);\n      ruv.x *= -1.0;\n      col += lineCol * wave(\n        ruv + vec2(topLineDistance * fi + topWavePosition.x, topWavePosition.y),\n        1.0 + 0.2 * fi,\n        baseUv,\n        mouseUv,\n        interactive\n      ) * 0.1;\n    }\n  }\n\n  fragColor = vec4(col, 1.0);\n}\n\nvoid main() {\n  vec4 color = vec4(0.0);\n  mainImage(color, gl_FragCoord.xy);\n  gl_FragColor = color;\n}\n`;\n\nconst MAX_GRADIENT_STOPS = 8;\n\nfunction hexToVec3(hex) {\n  let value = hex.trim();\n\n  if (value.startsWith('#')) {\n    value = value.slice(1);\n  }\n\n  let r = 255;\n  let g = 255;\n  let b = 255;\n\n  if (value.length === 3) {\n    r = parseInt(value[0] + value[0], 16);\n    g = parseInt(value[1] + value[1], 16);\n    b = parseInt(value[2] + value[2], 16);\n  } else if (value.length === 6) {\n    r = parseInt(value.slice(0, 2), 16);\n    g = parseInt(value.slice(2, 4), 16);\n    b = parseInt(value.slice(4, 6), 16);\n  }\n\n  return new Vector3(r / 255, g / 255, b / 255);\n}\n\nexport default function FloatingLines({\n  linesGradient,\n  enabledWaves = ['top', 'middle', 'bottom'],\n  lineCount = [6],\n  lineDistance = [5],\n  topWavePosition,\n  middleWavePosition,\n  bottomWavePosition = { x: 2.0, y: -0.7, rotate: -1 },\n  animationSpeed = 1,\n  interactive = true,\n  bendRadius = 5.0,\n  bendStrength = -0.5,\n  mouseDamping = 0.05,\n  parallax = true,\n  parallaxStrength = 0.2,\n  mixBlendMode = 'screen'\n}) {\n  const containerRef = useRef(null);\n  const targetMouseRef = useRef(new Vector2(-1000, -1000));\n  const currentMouseRef = useRef(new Vector2(-1000, -1000));\n  const targetInfluenceRef = useRef(0);\n  const currentInfluenceRef = useRef(0);\n  const targetParallaxRef = useRef(new Vector2(0, 0));\n  const currentParallaxRef = useRef(new Vector2(0, 0));\n\n  useEffect(() => {\n    if (!containerRef.current) return;\n\n    // Helper functions\n    const getLineCount = waveType => {\n      if (typeof lineCount === 'number') return lineCount;\n      if (!enabledWaves.includes(waveType)) return 0;\n      const index = enabledWaves.indexOf(waveType);\n      return lineCount[index] ?? 6;\n    };\n\n    const getLineDistance = waveType => {\n      if (typeof lineDistance === 'number') return lineDistance;\n      if (!enabledWaves.includes(waveType)) return 0.1;\n      const index = enabledWaves.indexOf(waveType);\n      return lineDistance[index] ?? 0.1;\n    };\n\n    // Calculate line counts and distances inside effect\n    const topLineCount = enabledWaves.includes('top') ? getLineCount('top') : 0;\n    const middleLineCount = enabledWaves.includes('middle') ? getLineCount('middle') : 0;\n    const bottomLineCount = enabledWaves.includes('bottom') ? getLineCount('bottom') : 0;\n\n    const topLineDistance = enabledWaves.includes('top') ? getLineDistance('top') * 0.01 : 0.01;\n    const middleLineDistance = enabledWaves.includes('middle') ? getLineDistance('middle') * 0.01 : 0.01;\n    const bottomLineDistance = enabledWaves.includes('bottom') ? getLineDistance('bottom') * 0.01 : 0.01;\n\n    const scene = new Scene();\n\n    const camera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);\n    camera.position.z = 1;\n\n    const renderer = new WebGLRenderer({ antialias: true, alpha: false });\n    renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));\n    renderer.domElement.style.width = '100%';\n    renderer.domElement.style.height = '100%';\n    containerRef.current.appendChild(renderer.domElement);\n\n    const uniforms = {\n      iTime: { value: 0 },\n      iResolution: { value: new Vector3(1, 1, 1) },\n      animationSpeed: { value: animationSpeed },\n\n      enableTop: { value: enabledWaves.includes('top') },\n      enableMiddle: { value: enabledWaves.includes('middle') },\n      enableBottom: { value: enabledWaves.includes('bottom') },\n\n      topLineCount: { value: topLineCount },\n      middleLineCount: { value: middleLineCount },\n      bottomLineCount: { value: bottomLineCount },\n\n      topLineDistance: { value: topLineDistance },\n      middleLineDistance: { value: middleLineDistance },\n      bottomLineDistance: { value: bottomLineDistance },\n\n      topWavePosition: {\n        value: new Vector3(topWavePosition?.x ?? 10.0, topWavePosition?.y ?? 0.5, topWavePosition?.rotate ?? -0.4)\n      },\n      middleWavePosition: {\n        value: new Vector3(\n          middleWavePosition?.x ?? 5.0,\n          middleWavePosition?.y ?? 0.0,\n          middleWavePosition?.rotate ?? 0.2\n        )\n      },\n      bottomWavePosition: {\n        value: new Vector3(\n          bottomWavePosition?.x ?? 2.0,\n          bottomWavePosition?.y ?? -0.7,\n          bottomWavePosition?.rotate ?? 0.4\n        )\n      },\n\n      iMouse: { value: new Vector2(-1000, -1000) },\n      interactive: { value: interactive },\n      bendRadius: { value: bendRadius },\n      bendStrength: { value: bendStrength },\n      bendInfluence: { value: 0 },\n\n      parallax: { value: parallax },\n      parallaxStrength: { value: parallaxStrength },\n      parallaxOffset: { value: new Vector2(0, 0) },\n\n      lineGradient: {\n        value: Array.from({ length: MAX_GRADIENT_STOPS }, () => new Vector3(1, 1, 1))\n      },\n      lineGradientCount: { value: 0 }\n    };\n\n    if (linesGradient && linesGradient.length > 0) {\n      const stops = linesGradient.slice(0, MAX_GRADIENT_STOPS);\n      uniforms.lineGradientCount.value = stops.length;\n\n      stops.forEach((hex, i) => {\n        const color = hexToVec3(hex);\n        uniforms.lineGradient.value[i].set(color.x, color.y, color.z);\n      });\n    }\n\n    const material = new ShaderMaterial({\n      uniforms,\n      vertexShader,\n      fragmentShader\n    });\n\n    const geometry = new PlaneGeometry(2, 2);\n    const mesh = new Mesh(geometry, material);\n    scene.add(mesh);\n\n    const clock = new Clock();\n\n    const setSize = () => {\n      const el = containerRef.current;\n      if (!el) {\n        return;\n      }\n      const width = el.clientWidth || 1;\n      const height = el.clientHeight || 1;\n\n      renderer.setSize(width, height, false);\n\n      const canvasWidth = renderer.domElement.width;\n      const canvasHeight = renderer.domElement.height;\n      uniforms.iResolution.value.set(canvasWidth, canvasHeight, 1);\n    };\n\n    setSize();\n\n    const ro = typeof ResizeObserver !== 'undefined' ? new ResizeObserver(setSize) : null;\n\n    if (ro && containerRef.current) {\n      ro.observe(containerRef.current);\n    }\n\n    const handlePointerMove = event => {\n      const rect = renderer.domElement.getBoundingClientRect();\n      const x = event.clientX - rect.left;\n      const y = event.clientY - rect.top;\n      const dpr = renderer.getPixelRatio();\n\n      targetMouseRef.current.set(x * dpr, (rect.height - y) * dpr);\n      targetInfluenceRef.current = 1.0;\n\n      if (parallax) {\n        const centerX = rect.width / 2;\n        const centerY = rect.height / 2;\n        const offsetX = (x - centerX) / rect.width;\n        const offsetY = -(y - centerY) / rect.height;\n        targetParallaxRef.current.set(offsetX * parallaxStrength, offsetY * parallaxStrength);\n      }\n    };\n\n    const handlePointerLeave = () => {\n      targetInfluenceRef.current = 0.0;\n    };\n\n    if (interactive) {\n      renderer.domElement.addEventListener('pointermove', handlePointerMove);\n      renderer.domElement.addEventListener('pointerleave', handlePointerLeave);\n    }\n\n    let raf = 0;\n    const renderLoop = () => {\n      uniforms.iTime.value = clock.getElapsedTime();\n\n      if (interactive) {\n        currentMouseRef.current.lerp(targetMouseRef.current, mouseDamping);\n        uniforms.iMouse.value.copy(currentMouseRef.current);\n\n        currentInfluenceRef.current += (targetInfluenceRef.current - currentInfluenceRef.current) * mouseDamping;\n        uniforms.bendInfluence.value = currentInfluenceRef.current;\n      }\n\n      if (parallax) {\n        currentParallaxRef.current.lerp(targetParallaxRef.current, mouseDamping);\n        uniforms.parallaxOffset.value.copy(currentParallaxRef.current);\n      }\n\n      renderer.render(scene, camera);\n      raf = requestAnimationFrame(renderLoop);\n    };\n    renderLoop();\n\n    const container = containerRef.current;\n    return () => {\n      cancelAnimationFrame(raf);\n      if (ro && container) {\n        ro.disconnect();\n      }\n\n      if (interactive) {\n        renderer.domElement.removeEventListener('pointermove', handlePointerMove);\n        renderer.domElement.removeEventListener('pointerleave', handlePointerLeave);\n      }\n\n      geometry.dispose();\n      material.dispose();\n      renderer.dispose();\n      if (renderer.domElement.parentElement) {\n        renderer.domElement.parentElement.removeChild(renderer.domElement);\n      }\n    };\n  }, [\n    linesGradient,\n    enabledWaves,\n    lineCount,\n    lineDistance,\n    topWavePosition,\n    middleWavePosition,\n    bottomWavePosition,\n    animationSpeed,\n    interactive,\n    bendRadius,\n    bendStrength,\n    mouseDamping,\n    parallax,\n    parallaxStrength\n  ]);\n\n  return (\n    <div\n      ref={containerRef}\n      className=\"floating-lines-container\"\n      style={{\n        mixBlendMode: mixBlendMode\n      }}\n    />\n  );\n}\n"],"mappings":";;AAAA,SAASA,SAAS,EAAEC,MAAM,QAAQ,OAAO;AACzC,SACEC,KAAK,EACLC,kBAAkB,EAClBC,aAAa,EACbC,aAAa,EACbC,IAAI,EACJC,cAAc,EACdC,OAAO,EACPC,OAAO,EACPC,KAAK,QACA,OAAO;AAEd,OAAO,qBAAqB;AAAC,SAAAC,MAAA,IAAAC,OAAA;AAE7B,MAAMC,YAAY,GAAG;AACrB;AACA;AACA;AACA;AACA;AACA,CAAC;AAED,MAAMC,cAAc,GAAG;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AAED,MAAMC,kBA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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}