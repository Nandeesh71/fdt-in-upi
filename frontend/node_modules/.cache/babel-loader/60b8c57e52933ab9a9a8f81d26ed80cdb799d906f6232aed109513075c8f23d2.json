{"ast":null,"code":"import{useEffect,useRef,memo}from'react';import{Scene,OrthographicCamera,WebGLRenderer,PlaneGeometry,Mesh,ShaderMaterial,Vector3,Vector2,Clock}from'three';import'./FloatingLines.css';import{jsx as _jsx}from\"react/jsx-runtime\";const vertexShader=\"\\nprecision highp float;\\n\\nvoid main() {\\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\\n}\\n\";const fragmentShader=\"\\nprecision highp float;\\n\\nuniform float iTime;\\nuniform vec3  iResolution;\\nuniform float animationSpeed;\\n\\nuniform bool enableTop;\\nuniform bool enableMiddle;\\nuniform bool enableBottom;\\n\\nuniform int topLineCount;\\nuniform int middleLineCount;\\nuniform int bottomLineCount;\\n\\nuniform float topLineDistance;\\nuniform float middleLineDistance;\\nuniform float bottomLineDistance;\\n\\nuniform vec3 topWavePosition;\\nuniform vec3 middleWavePosition;\\nuniform vec3 bottomWavePosition;\\n\\nuniform vec2 iMouse;\\nuniform bool interactive;\\nuniform float bendRadius;\\nuniform float bendStrength;\\nuniform float bendInfluence;\\n\\nuniform bool parallax;\\nuniform float parallaxStrength;\\nuniform vec2 parallaxOffset;\\n\\nuniform vec3 lineGradient[8];\\nuniform int lineGradientCount;\\n\\nconst vec3 BLACK = vec3(0.0);\\nconst vec3 PINK  = vec3(233.0, 71.0, 245.0) / 255.0;\\nconst vec3 BLUE  = vec3(47.0,  75.0, 162.0) / 255.0;\\n\\nmat2 rotate(float r) {\\n  return mat2(cos(r), sin(r), -sin(r), cos(r));\\n}\\n\\nvec3 background_color(vec2 uv) {\\n  vec3 col = vec3(0.0);\\n\\n  float y = sin(uv.x - 0.2) * 0.3 - 0.1;\\n  float m = uv.y - y;\\n\\n  col += mix(BLUE, BLACK, smoothstep(0.0, 1.0, abs(m)));\\n  col += mix(PINK, BLACK, smoothstep(0.0, 1.0, abs(m - 0.8)));\\n  return col * 0.5;\\n}\\n\\nvec3 getLineColor(float t, vec3 baseColor) {\\n  if (lineGradientCount <= 0) {\\n    return baseColor;\\n  }\\n\\n  vec3 gradientColor;\\n  \\n  if (lineGradientCount == 1) {\\n    gradientColor = lineGradient[0];\\n  } else {\\n    float clampedT = clamp(t, 0.0, 0.9999);\\n    float scaled = clampedT * float(lineGradientCount - 1);\\n    int idx = int(floor(scaled));\\n    float f = fract(scaled);\\n    int idx2 = min(idx + 1, lineGradientCount - 1);\\n\\n    vec3 c1 = lineGradient[idx];\\n    vec3 c2 = lineGradient[idx2];\\n    \\n    gradientColor = mix(c1, c2, f);\\n  }\\n  \\n  return gradientColor * 0.5;\\n}\\n\\n  float wave(vec2 uv, float offset, vec2 screenUv, vec2 mouseUv, bool shouldBend) {\\n  float time = iTime * animationSpeed;\\n\\n  float x_offset   = offset;\\n  float x_movement = time * 0.1;\\n  float amp        = sin(offset + time * 0.2) * 0.3;\\n  float y          = sin(uv.x + x_offset + x_movement) * amp;\\n\\n  if (shouldBend) {\\n    vec2 d = screenUv - mouseUv;\\n    float influence = exp(-dot(d, d) * bendRadius); // radial falloff around cursor\\n    float bendOffset = (mouseUv.y - screenUv.y) * influence * bendStrength * bendInfluence;\\n    y += bendOffset;\\n  }\\n\\n  float m = uv.y - y;\\n  return 0.0175 / max(abs(m) + 0.01, 1e-3) + 0.01;\\n}\\n\\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\\n  vec2 baseUv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\\n  baseUv.y *= -1.0;\\n  \\n  if (parallax) {\\n    baseUv += parallaxOffset;\\n  }\\n\\n  vec3 col = vec3(0.0);\\n\\n  vec3 b = lineGradientCount > 0 ? vec3(0.0) : background_color(baseUv);\\n\\n  vec2 mouseUv = vec2(0.0);\\n  if (interactive) {\\n    mouseUv = (2.0 * iMouse - iResolution.xy) / iResolution.y;\\n    mouseUv.y *= -1.0;\\n  }\\n  \\n  if (enableBottom) {\\n    for (int i = 0; i < bottomLineCount; ++i) {\\n      float fi = float(i);\\n      float t = fi / max(float(bottomLineCount - 1), 1.0);\\n      vec3 lineCol = getLineColor(t, b);\\n      \\n      float angle = bottomWavePosition.z * log(length(baseUv) + 1.0);\\n      vec2 ruv = baseUv * rotate(angle);\\n      col += lineCol * wave(\\n        ruv + vec2(bottomLineDistance * fi + bottomWavePosition.x, bottomWavePosition.y),\\n        1.5 + 0.2 * fi,\\n        baseUv,\\n        mouseUv,\\n        interactive\\n      ) * 0.2;\\n    }\\n  }\\n\\n  if (enableMiddle) {\\n    for (int i = 0; i < middleLineCount; ++i) {\\n      float fi = float(i);\\n      float t = fi / max(float(middleLineCount - 1), 1.0);\\n      vec3 lineCol = getLineColor(t, b);\\n      \\n      float angle = middleWavePosition.z * log(length(baseUv) + 1.0);\\n      vec2 ruv = baseUv * rotate(angle);\\n      col += lineCol * wave(\\n        ruv + vec2(middleLineDistance * fi + middleWavePosition.x, middleWavePosition.y),\\n        2.0 + 0.15 * fi,\\n        baseUv,\\n        mouseUv,\\n        interactive\\n      );\\n    }\\n  }\\n\\n  if (enableTop) {\\n    for (int i = 0; i < topLineCount; ++i) {\\n      float fi = float(i);\\n      float t = fi / max(float(topLineCount - 1), 1.0);\\n      vec3 lineCol = getLineColor(t, b);\\n      \\n      float angle = topWavePosition.z * log(length(baseUv) + 1.0);\\n      vec2 ruv = baseUv * rotate(angle);\\n      ruv.x *= -1.0;\\n      col += lineCol * wave(\\n        ruv + vec2(topLineDistance * fi + topWavePosition.x, topWavePosition.y),\\n        1.0 + 0.2 * fi,\\n        baseUv,\\n        mouseUv,\\n        interactive\\n      ) * 0.1;\\n    }\\n  }\\n\\n  fragColor = vec4(col, 1.0);\\n}\\n\\nvoid main() {\\n  vec4 color = vec4(0.0);\\n  mainImage(color, gl_FragCoord.xy);\\n  gl_FragColor = color;\\n}\\n\";const MAX_GRADIENT_STOPS=8;function hexToVec3(hex){let value=hex.trim();if(value.startsWith('#')){value=value.slice(1);}let r=255;let g=255;let b=255;if(value.length===3){r=parseInt(value[0]+value[0],16);g=parseInt(value[1]+value[1],16);b=parseInt(value[2]+value[2],16);}else if(value.length===6){r=parseInt(value.slice(0,2),16);g=parseInt(value.slice(2,4),16);b=parseInt(value.slice(4,6),16);}return new Vector3(r/255,g/255,b/255);}function FloatingLines(_ref){let{linesGradient,enabledWaves=['top','middle','bottom'],lineCount=[6],lineDistance=[5],topWavePosition,middleWavePosition,bottomWavePosition={x:2.0,y:-0.7,rotate:-1},animationSpeed=1,interactive=true,bendRadius=5.0,bendStrength=-0.5,mouseDamping=0.05,parallax=true,parallaxStrength=0.2,mixBlendMode='screen'}=_ref;const containerRef=useRef(null);const targetMouseRef=useRef(new Vector2(-1000,-1000));const currentMouseRef=useRef(new Vector2(-1000,-1000));const targetInfluenceRef=useRef(0);const currentInfluenceRef=useRef(0);const targetParallaxRef=useRef(new Vector2(0,0));const currentParallaxRef=useRef(new Vector2(0,0));useEffect(()=>{var _topWavePosition$x,_topWavePosition$y,_topWavePosition$rota,_middleWavePosition$x,_middleWavePosition$y,_middleWavePosition$r,_bottomWavePosition$x,_bottomWavePosition$y,_bottomWavePosition$r;if(!containerRef.current)return;// Helper functions\nconst getLineCount=waveType=>{var _lineCount$index;if(typeof lineCount==='number')return lineCount;if(!enabledWaves.includes(waveType))return 0;const index=enabledWaves.indexOf(waveType);return(_lineCount$index=lineCount[index])!==null&&_lineCount$index!==void 0?_lineCount$index:6;};const getLineDistance=waveType=>{var _lineDistance$index;if(typeof lineDistance==='number')return lineDistance;if(!enabledWaves.includes(waveType))return 0.1;const index=enabledWaves.indexOf(waveType);return(_lineDistance$index=lineDistance[index])!==null&&_lineDistance$index!==void 0?_lineDistance$index:0.1;};// Calculate line counts and distances inside effect\nconst topLineCount=enabledWaves.includes('top')?getLineCount('top'):0;const middleLineCount=enabledWaves.includes('middle')?getLineCount('middle'):0;const bottomLineCount=enabledWaves.includes('bottom')?getLineCount('bottom'):0;const topLineDistance=enabledWaves.includes('top')?getLineDistance('top')*0.01:0.01;const middleLineDistance=enabledWaves.includes('middle')?getLineDistance('middle')*0.01:0.01;const bottomLineDistance=enabledWaves.includes('bottom')?getLineDistance('bottom')*0.01:0.01;const scene=new Scene();const camera=new OrthographicCamera(-1,1,1,-1,0,1);camera.position.z=1;const renderer=new WebGLRenderer({antialias:true,alpha:false});renderer.setPixelRatio(Math.min(window.devicePixelRatio||1,2));renderer.domElement.style.width='100%';renderer.domElement.style.height='100%';containerRef.current.appendChild(renderer.domElement);const uniforms={iTime:{value:0},iResolution:{value:new Vector3(1,1,1)},animationSpeed:{value:animationSpeed},enableTop:{value:enabledWaves.includes('top')},enableMiddle:{value:enabledWaves.includes('middle')},enableBottom:{value:enabledWaves.includes('bottom')},topLineCount:{value:topLineCount},middleLineCount:{value:middleLineCount},bottomLineCount:{value:bottomLineCount},topLineDistance:{value:topLineDistance},middleLineDistance:{value:middleLineDistance},bottomLineDistance:{value:bottomLineDistance},topWavePosition:{value:new Vector3((_topWavePosition$x=topWavePosition===null||topWavePosition===void 0?void 0:topWavePosition.x)!==null&&_topWavePosition$x!==void 0?_topWavePosition$x:10.0,(_topWavePosition$y=topWavePosition===null||topWavePosition===void 0?void 0:topWavePosition.y)!==null&&_topWavePosition$y!==void 0?_topWavePosition$y:0.5,(_topWavePosition$rota=topWavePosition===null||topWavePosition===void 0?void 0:topWavePosition.rotate)!==null&&_topWavePosition$rota!==void 0?_topWavePosition$rota:-0.4)},middleWavePosition:{value:new Vector3((_middleWavePosition$x=middleWavePosition===null||middleWavePosition===void 0?void 0:middleWavePosition.x)!==null&&_middleWavePosition$x!==void 0?_middleWavePosition$x:5.0,(_middleWavePosition$y=middleWavePosition===null||middleWavePosition===void 0?void 0:middleWavePosition.y)!==null&&_middleWavePosition$y!==void 0?_middleWavePosition$y:0.0,(_middleWavePosition$r=middleWavePosition===null||middleWavePosition===void 0?void 0:middleWavePosition.rotate)!==null&&_middleWavePosition$r!==void 0?_middleWavePosition$r:0.2)},bottomWavePosition:{value:new Vector3((_bottomWavePosition$x=bottomWavePosition===null||bottomWavePosition===void 0?void 0:bottomWavePosition.x)!==null&&_bottomWavePosition$x!==void 0?_bottomWavePosition$x:2.0,(_bottomWavePosition$y=bottomWavePosition===null||bottomWavePosition===void 0?void 0:bottomWavePosition.y)!==null&&_bottomWavePosition$y!==void 0?_bottomWavePosition$y:-0.7,(_bottomWavePosition$r=bottomWavePosition===null||bottomWavePosition===void 0?void 0:bottomWavePosition.rotate)!==null&&_bottomWavePosition$r!==void 0?_bottomWavePosition$r:0.4)},iMouse:{value:new Vector2(-1000,-1000)},interactive:{value:interactive},bendRadius:{value:bendRadius},bendStrength:{value:bendStrength},bendInfluence:{value:0},parallax:{value:parallax},parallaxStrength:{value:parallaxStrength},parallaxOffset:{value:new Vector2(0,0)},lineGradient:{value:Array.from({length:MAX_GRADIENT_STOPS},()=>new Vector3(1,1,1))},lineGradientCount:{value:0}};if(linesGradient&&linesGradient.length>0){const stops=linesGradient.slice(0,MAX_GRADIENT_STOPS);uniforms.lineGradientCount.value=stops.length;stops.forEach((hex,i)=>{const color=hexToVec3(hex);uniforms.lineGradient.value[i].set(color.x,color.y,color.z);});}const material=new ShaderMaterial({uniforms,vertexShader,fragmentShader});const geometry=new PlaneGeometry(2,2);const mesh=new Mesh(geometry,material);scene.add(mesh);const clock=new Clock();const setSize=()=>{const el=containerRef.current;if(!el){return;}const width=el.clientWidth||1;const height=el.clientHeight||1;renderer.setSize(width,height,false);const canvasWidth=renderer.domElement.width;const canvasHeight=renderer.domElement.height;uniforms.iResolution.value.set(canvasWidth,canvasHeight,1);};setSize();let resizeTimeout;const debouncedSetSize=()=>{clearTimeout(resizeTimeout);resizeTimeout=setTimeout(setSize,100);};const ro=typeof ResizeObserver!=='undefined'?new ResizeObserver(debouncedSetSize):null;if(ro&&containerRef.current){ro.observe(containerRef.current);}const handlePointerMove=event=>{const rect=renderer.domElement.getBoundingClientRect();const x=event.clientX-rect.left;const y=event.clientY-rect.top;const dpr=renderer.getPixelRatio();targetMouseRef.current.set(x*dpr,(rect.height-y)*dpr);targetInfluenceRef.current=1.0;if(parallax){const centerX=rect.width/2;const centerY=rect.height/2;const offsetX=(x-centerX)/rect.width;const offsetY=-(y-centerY)/rect.height;targetParallaxRef.current.set(offsetX*parallaxStrength,offsetY*parallaxStrength);}};const handlePointerLeave=()=>{targetInfluenceRef.current=0.0;};if(interactive){renderer.domElement.addEventListener('pointermove',handlePointerMove);renderer.domElement.addEventListener('pointerleave',handlePointerLeave);}let raf=0;const renderLoop=()=>{uniforms.iTime.value=clock.getElapsedTime();if(interactive){currentMouseRef.current.lerp(targetMouseRef.current,mouseDamping);uniforms.iMouse.value.copy(currentMouseRef.current);currentInfluenceRef.current+=(targetInfluenceRef.current-currentInfluenceRef.current)*mouseDamping;uniforms.bendInfluence.value=currentInfluenceRef.current;}if(parallax){currentParallaxRef.current.lerp(targetParallaxRef.current,mouseDamping);uniforms.parallaxOffset.value.copy(currentParallaxRef.current);}renderer.render(scene,camera);raf=requestAnimationFrame(renderLoop);};renderLoop();const container=containerRef.current;return()=>{cancelAnimationFrame(raf);clearTimeout(resizeTimeout);if(ro&&container){ro.disconnect();}if(interactive){renderer.domElement.removeEventListener('pointermove',handlePointerMove);renderer.domElement.removeEventListener('pointerleave',handlePointerLeave);}geometry.dispose();material.dispose();renderer.dispose();if(renderer.domElement.parentElement){renderer.domElement.parentElement.removeChild(renderer.domElement);}};},[linesGradient,enabledWaves,lineCount,lineDistance,topWavePosition,middleWavePosition,bottomWavePosition,animationSpeed,interactive,bendRadius,bendStrength,mouseDamping,parallax,parallaxStrength]);return/*#__PURE__*/_jsx(\"div\",{ref:containerRef,className:\"floating-lines-container\",style:{mixBlendMode:mixBlendMode}});}export default/*#__PURE__*/memo(FloatingLines);","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}